// Code generated by eevee. DO NOT EDIT!

package repository

import (
	"/entity"
	"/model"
	"context"
	"log"
	"reflect"

	"golang.org/x/xerrors"
)

type SkillMock struct {
	expect *SkillExpect
}

func (r *SkillMock) EXPECT() *SkillExpect {
	return r.expect
}

func NewSkillMock() *SkillMock {
	return &SkillMock{expect: NewSkillExpect()}
}

type SkillToModelExpect struct {
	expect        *SkillExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(value *entity.Skill)
	value         *entity.Skill
	r0            *model.Skill
}

func (r *SkillToModelExpect) Return(r0 *model.Skill) *SkillToModelExpect {
	r.r0 = r0
	return r
}

func (r *SkillToModelExpect) Do(action func(value *entity.Skill)) *SkillToModelExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *SkillToModelExpect) OutOfOrder() *SkillToModelExpect {
	r.isOutOfOrder = true
	return r
}

func (r *SkillToModelExpect) AnyTimes() *SkillToModelExpect {
	r.isAnyTimes = true
	return r
}

func (r *SkillToModelExpect) Times(n int) *SkillToModelExpect {
	r.requiredTimes = n
	return r
}

func (r *SkillMock) ToModel(value *entity.Skill) (r0 *model.Skill) {
	if len(r.expect.toModel) == 0 {
		log.Printf("cannot find mock method for Skill.ToModel")
		return
	}
	for _, exp := range r.expect.toModel {
		if !reflect.DeepEqual(exp.value, value) {
			continue
		}
		for _, action := range exp.actions {
			action(value)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			log.Printf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	log.Printf("invalid argument Skill value:[%+v]", value)
	return
}

func (r *SkillExpect) ToModel(value *entity.Skill) *SkillToModelExpect {
	exp := &SkillToModelExpect{
		actions: []func(value *entity.Skill){},
		expect:  r,
		value:   value,
	}
	r.toModel = append(r.toModel, exp)
	return exp
}

type SkillToModelsExpect struct {
	expect        *SkillExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(values entity.Skills)
	values        entity.Skills
	r0            *model.Skills
}

func (r *SkillToModelsExpect) Return(r0 *model.Skills) *SkillToModelsExpect {
	r.r0 = r0
	return r
}

func (r *SkillToModelsExpect) Do(action func(values entity.Skills)) *SkillToModelsExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *SkillToModelsExpect) OutOfOrder() *SkillToModelsExpect {
	r.isOutOfOrder = true
	return r
}

func (r *SkillToModelsExpect) AnyTimes() *SkillToModelsExpect {
	r.isAnyTimes = true
	return r
}

func (r *SkillToModelsExpect) Times(n int) *SkillToModelsExpect {
	r.requiredTimes = n
	return r
}

func (r *SkillMock) ToModels(values entity.Skills) (r0 *model.Skills) {
	if len(r.expect.toModels) == 0 {
		log.Printf("cannot find mock method for Skill.ToModels")
		return
	}
	for _, exp := range r.expect.toModels {
		if !reflect.DeepEqual(exp.values, values) {
			continue
		}
		for _, action := range exp.actions {
			action(values)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			log.Printf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	log.Printf("invalid argument Skill values:[%+v]", values)
	return
}

func (r *SkillExpect) ToModels(values entity.Skills) *SkillToModelsExpect {
	exp := &SkillToModelsExpect{
		actions: []func(values entity.Skills){},
		expect:  r,
		values:  values,
	}
	r.toModels = append(r.toModels, exp)
	return exp
}

type SkillCreateExpect struct {
	expect        *SkillExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(ctx context.Context, value *entity.Skill)
	ctx           context.Context
	value         *entity.Skill
	r0            *model.Skill
	r1            error
}

func (r *SkillCreateExpect) Return(r0 *model.Skill, r1 error) *SkillCreateExpect {
	r.r0 = r0
	r.r1 = r1
	return r
}

func (r *SkillCreateExpect) Do(action func(ctx context.Context, value *entity.Skill)) *SkillCreateExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *SkillCreateExpect) OutOfOrder() *SkillCreateExpect {
	r.isOutOfOrder = true
	return r
}

func (r *SkillCreateExpect) AnyTimes() *SkillCreateExpect {
	r.isAnyTimes = true
	return r
}

func (r *SkillCreateExpect) Times(n int) *SkillCreateExpect {
	r.requiredTimes = n
	return r
}

func (r *SkillMock) Create(ctx context.Context, value *entity.Skill) (r0 *model.Skill, r1 error) {
	if len(r.expect.create) == 0 {
		r1 = xerrors.New("cannot find mock method for Skill.Create")
		return
	}
	for _, exp := range r.expect.create {
		if !reflect.DeepEqual(exp.ctx, ctx) {
			continue
		}
		if !reflect.DeepEqual(exp.value, value) {
			continue
		}
		for _, action := range exp.actions {
			action(ctx, value)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			r1 = exp.r1
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r1 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		r1 = exp.r1
		return
	}
	r1 = xerrors.Errorf("invalid argument Skill ctx:[%+v] value:[%+v]", ctx, value)
	return
}

func (r *SkillExpect) Create(ctx context.Context, value *entity.Skill) *SkillCreateExpect {
	exp := &SkillCreateExpect{
		actions: []func(ctx context.Context, value *entity.Skill){},
		ctx:     ctx,
		expect:  r,
		value:   value,
	}
	r.create = append(r.create, exp)
	return exp
}

type SkillCreatesExpect struct {
	expect        *SkillExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(ctx context.Context, entities entity.Skills)
	ctx           context.Context
	entities      entity.Skills
	r0            *model.Skills
	r1            error
}

func (r *SkillCreatesExpect) Return(r0 *model.Skills, r1 error) *SkillCreatesExpect {
	r.r0 = r0
	r.r1 = r1
	return r
}

func (r *SkillCreatesExpect) Do(action func(ctx context.Context, entities entity.Skills)) *SkillCreatesExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *SkillCreatesExpect) OutOfOrder() *SkillCreatesExpect {
	r.isOutOfOrder = true
	return r
}

func (r *SkillCreatesExpect) AnyTimes() *SkillCreatesExpect {
	r.isAnyTimes = true
	return r
}

func (r *SkillCreatesExpect) Times(n int) *SkillCreatesExpect {
	r.requiredTimes = n
	return r
}

func (r *SkillMock) Creates(ctx context.Context, entities entity.Skills) (r0 *model.Skills, r1 error) {
	if len(r.expect.creates) == 0 {
		r1 = xerrors.New("cannot find mock method for Skill.Creates")
		return
	}
	for _, exp := range r.expect.creates {
		if !reflect.DeepEqual(exp.ctx, ctx) {
			continue
		}
		if !reflect.DeepEqual(exp.entities, entities) {
			continue
		}
		for _, action := range exp.actions {
			action(ctx, entities)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			r1 = exp.r1
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r1 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		r1 = exp.r1
		return
	}
	r1 = xerrors.Errorf("invalid argument Skill ctx:[%+v] entities:[%+v]", ctx, entities)
	return
}

func (r *SkillExpect) Creates(ctx context.Context, entities entity.Skills) *SkillCreatesExpect {
	exp := &SkillCreatesExpect{
		actions:  []func(ctx context.Context, entities entity.Skills){},
		ctx:      ctx,
		entities: entities,
		expect:   r,
	}
	r.creates = append(r.creates, exp)
	return exp
}

type SkillExpect struct {
	toModel  []*SkillToModelExpect
	toModels []*SkillToModelsExpect
	create   []*SkillCreateExpect
	creates  []*SkillCreatesExpect
}

func NewSkillExpect() *SkillExpect {
	return &SkillExpect{
		create:   []*SkillCreateExpect{},
		creates:  []*SkillCreatesExpect{},
		toModel:  []*SkillToModelExpect{},
		toModels: []*SkillToModelsExpect{},
	}
}
