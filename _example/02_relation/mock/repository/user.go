// Code generated by eevee. DO NOT EDIT!

package repository

import (
	"context"
	"log"
	"reflect"
	"relation/entity"
	"relation/model"

	"golang.org/x/xerrors"
)

type UserMock struct {
	expect *UserExpect
}

func (r *UserMock) EXPECT() *UserExpect {
	return r.expect
}

func NewUserMock() *UserMock {
	return &UserMock{expect: NewUserExpect()}
}

type UserToModelExpect struct {
	expect        *UserExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(value *entity.User)
	value         *entity.User
	r0            *model.User
}

func (r *UserToModelExpect) Return(r0 *model.User) *UserToModelExpect {
	r.r0 = r0
	return r
}

func (r *UserToModelExpect) Do(action func(value *entity.User)) *UserToModelExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserToModelExpect) OutOfOrder() *UserToModelExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserToModelExpect) AnyTimes() *UserToModelExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserToModelExpect) Times(n int) *UserToModelExpect {
	r.requiredTimes = n
	return r
}

func (r *UserMock) ToModel(value *entity.User) (r0 *model.User) {
	if len(r.expect.toModel) == 0 {
		log.Printf("cannot find mock method for User.ToModel")
		return
	}
	for _, exp := range r.expect.toModel {
		if !reflect.DeepEqual(exp.value, value) {
			continue
		}
		for _, action := range exp.actions {
			action(value)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			log.Printf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	log.Printf("invalid argument User value:[%+v]", value)
	return
}

func (r *UserExpect) ToModel(value *entity.User) *UserToModelExpect {
	exp := &UserToModelExpect{
		actions: []func(value *entity.User){},
		expect:  r,
		value:   value,
	}
	r.toModel = append(r.toModel, exp)
	return exp
}

type UserToModelsExpect struct {
	expect        *UserExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(values entity.Users)
	values        entity.Users
	r0            *model.Users
}

func (r *UserToModelsExpect) Return(r0 *model.Users) *UserToModelsExpect {
	r.r0 = r0
	return r
}

func (r *UserToModelsExpect) Do(action func(values entity.Users)) *UserToModelsExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserToModelsExpect) OutOfOrder() *UserToModelsExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserToModelsExpect) AnyTimes() *UserToModelsExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserToModelsExpect) Times(n int) *UserToModelsExpect {
	r.requiredTimes = n
	return r
}

func (r *UserMock) ToModels(values entity.Users) (r0 *model.Users) {
	if len(r.expect.toModels) == 0 {
		log.Printf("cannot find mock method for User.ToModels")
		return
	}
	for _, exp := range r.expect.toModels {
		if !reflect.DeepEqual(exp.values, values) {
			continue
		}
		for _, action := range exp.actions {
			action(values)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			log.Printf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	log.Printf("invalid argument User values:[%+v]", values)
	return
}

func (r *UserExpect) ToModels(values entity.Users) *UserToModelsExpect {
	exp := &UserToModelsExpect{
		actions: []func(values entity.Users){},
		expect:  r,
		values:  values,
	}
	r.toModels = append(r.toModels, exp)
	return exp
}

type UserCreateExpect struct {
	expect        *UserExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(ctx context.Context, value *entity.User)
	ctx           context.Context
	value         *entity.User
	r0            *model.User
	r1            error
}

func (r *UserCreateExpect) Return(r0 *model.User, r1 error) *UserCreateExpect {
	r.r0 = r0
	r.r1 = r1
	return r
}

func (r *UserCreateExpect) Do(action func(ctx context.Context, value *entity.User)) *UserCreateExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserCreateExpect) OutOfOrder() *UserCreateExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserCreateExpect) AnyTimes() *UserCreateExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserCreateExpect) Times(n int) *UserCreateExpect {
	r.requiredTimes = n
	return r
}

func (r *UserMock) Create(ctx context.Context, value *entity.User) (r0 *model.User, r1 error) {
	if len(r.expect.create) == 0 {
		r1 = xerrors.New("cannot find mock method for User.Create")
		return
	}
	for _, exp := range r.expect.create {
		if !reflect.DeepEqual(exp.ctx, ctx) {
			continue
		}
		if !reflect.DeepEqual(exp.value, value) {
			continue
		}
		for _, action := range exp.actions {
			action(ctx, value)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			r1 = exp.r1
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r1 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		r1 = exp.r1
		return
	}
	r1 = xerrors.Errorf("invalid argument User ctx:[%+v] value:[%+v]", ctx, value)
	return
}

func (r *UserExpect) Create(ctx context.Context, value *entity.User) *UserCreateExpect {
	exp := &UserCreateExpect{
		actions: []func(ctx context.Context, value *entity.User){},
		ctx:     ctx,
		expect:  r,
		value:   value,
	}
	r.create = append(r.create, exp)
	return exp
}

type UserCreatesExpect struct {
	expect        *UserExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(ctx context.Context, entities entity.Users)
	ctx           context.Context
	entities      entity.Users
	r0            *model.Users
	r1            error
}

func (r *UserCreatesExpect) Return(r0 *model.Users, r1 error) *UserCreatesExpect {
	r.r0 = r0
	r.r1 = r1
	return r
}

func (r *UserCreatesExpect) Do(action func(ctx context.Context, entities entity.Users)) *UserCreatesExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserCreatesExpect) OutOfOrder() *UserCreatesExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserCreatesExpect) AnyTimes() *UserCreatesExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserCreatesExpect) Times(n int) *UserCreatesExpect {
	r.requiredTimes = n
	return r
}

func (r *UserMock) Creates(ctx context.Context, entities entity.Users) (r0 *model.Users, r1 error) {
	if len(r.expect.creates) == 0 {
		r1 = xerrors.New("cannot find mock method for User.Creates")
		return
	}
	for _, exp := range r.expect.creates {
		if !reflect.DeepEqual(exp.ctx, ctx) {
			continue
		}
		if !reflect.DeepEqual(exp.entities, entities) {
			continue
		}
		for _, action := range exp.actions {
			action(ctx, entities)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			r1 = exp.r1
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r1 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		r1 = exp.r1
		return
	}
	r1 = xerrors.Errorf("invalid argument User ctx:[%+v] entities:[%+v]", ctx, entities)
	return
}

func (r *UserExpect) Creates(ctx context.Context, entities entity.Users) *UserCreatesExpect {
	exp := &UserCreatesExpect{
		actions:  []func(ctx context.Context, entities entity.Users){},
		ctx:      ctx,
		entities: entities,
		expect:   r,
	}
	r.creates = append(r.creates, exp)
	return exp
}

type UserFindAllExpect struct {
	expect        *UserExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context)
	a0            context.Context
	r0            *model.Users
	r1            error
}

func (r *UserFindAllExpect) Return(r0 *model.Users, r1 error) *UserFindAllExpect {
	r.r0 = r0
	r.r1 = r1
	return r
}

func (r *UserFindAllExpect) Do(action func(a0 context.Context)) *UserFindAllExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserFindAllExpect) OutOfOrder() *UserFindAllExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserFindAllExpect) AnyTimes() *UserFindAllExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserFindAllExpect) Times(n int) *UserFindAllExpect {
	r.requiredTimes = n
	return r
}

func (r *UserMock) FindAll(a0 context.Context) (r0 *model.Users, r1 error) {
	if len(r.expect.findAll) == 0 {
		r1 = xerrors.New("cannot find mock method for User.FindAll")
		return
	}
	for _, exp := range r.expect.findAll {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		for _, action := range exp.actions {
			action(a0)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			r1 = exp.r1
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r1 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		r1 = exp.r1
		return
	}
	r1 = xerrors.Errorf("invalid argument User a0:[%+v]", a0)
	return
}

func (r *UserExpect) FindAll(a0 context.Context) *UserFindAllExpect {
	exp := &UserFindAllExpect{
		a0:      a0,
		actions: []func(a0 context.Context){},
		expect:  r,
	}
	r.findAll = append(r.findAll, exp)
	return exp
}

type UserFindByGroupIDExpect struct {
	expect        *UserExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 uint64)
	a0            context.Context
	a1            uint64
	r0            *model.Users
	r1            error
}

func (r *UserFindByGroupIDExpect) Return(r0 *model.Users, r1 error) *UserFindByGroupIDExpect {
	r.r0 = r0
	r.r1 = r1
	return r
}

func (r *UserFindByGroupIDExpect) Do(action func(a0 context.Context, a1 uint64)) *UserFindByGroupIDExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserFindByGroupIDExpect) OutOfOrder() *UserFindByGroupIDExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserFindByGroupIDExpect) AnyTimes() *UserFindByGroupIDExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserFindByGroupIDExpect) Times(n int) *UserFindByGroupIDExpect {
	r.requiredTimes = n
	return r
}

func (r *UserMock) FindByGroupID(a0 context.Context, a1 uint64) (r0 *model.Users, r1 error) {
	if len(r.expect.findByGroupID) == 0 {
		r1 = xerrors.New("cannot find mock method for User.FindByGroupID")
		return
	}
	for _, exp := range r.expect.findByGroupID {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			r1 = exp.r1
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r1 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		r1 = exp.r1
		return
	}
	r1 = xerrors.Errorf("invalid argument User a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *UserExpect) FindByGroupID(a0 context.Context, a1 uint64) *UserFindByGroupIDExpect {
	exp := &UserFindByGroupIDExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 uint64){},
		expect:  r,
	}
	r.findByGroupID = append(r.findByGroupID, exp)
	return exp
}

type UserFindByGroupIDsExpect struct {
	expect        *UserExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 []uint64)
	a0            context.Context
	a1            []uint64
	r0            *model.Users
	r1            error
}

func (r *UserFindByGroupIDsExpect) Return(r0 *model.Users, r1 error) *UserFindByGroupIDsExpect {
	r.r0 = r0
	r.r1 = r1
	return r
}

func (r *UserFindByGroupIDsExpect) Do(action func(a0 context.Context, a1 []uint64)) *UserFindByGroupIDsExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserFindByGroupIDsExpect) OutOfOrder() *UserFindByGroupIDsExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserFindByGroupIDsExpect) AnyTimes() *UserFindByGroupIDsExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserFindByGroupIDsExpect) Times(n int) *UserFindByGroupIDsExpect {
	r.requiredTimes = n
	return r
}

func (r *UserMock) FindByGroupIDs(a0 context.Context, a1 []uint64) (r0 *model.Users, r1 error) {
	if len(r.expect.findByGroupIDs) == 0 {
		r1 = xerrors.New("cannot find mock method for User.FindByGroupIDs")
		return
	}
	for _, exp := range r.expect.findByGroupIDs {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if len(exp.a1) != len(a1) {
			continue
		}
		if exp.isOutOfOrder {
			isMatched := func() bool {
				for _, exp := range exp.a1 {
					found := false
					for idx, act := range a1 {
						if exp != act {
							continue
						}
						a1 = append(a1[:idx], a1[idx+1:]...)
						found = true
						break
					}
					if !found {
						return false
					}
				}
				return true
			}()
			if !isMatched {
				continue
			}
		} else {
			if !reflect.DeepEqual(exp.a1, a1) {
				continue
			}
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			r1 = exp.r1
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r1 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		r1 = exp.r1
		return
	}
	r1 = xerrors.Errorf("invalid argument User a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *UserExpect) FindByGroupIDs(a0 context.Context, a1 []uint64) *UserFindByGroupIDsExpect {
	exp := &UserFindByGroupIDsExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 []uint64){},
		expect:  r,
	}
	r.findByGroupIDs = append(r.findByGroupIDs, exp)
	return exp
}

type UserFindByIDExpect struct {
	expect        *UserExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 uint64)
	a0            context.Context
	a1            uint64
	r0            *model.User
	r1            error
}

func (r *UserFindByIDExpect) Return(r0 *model.User, r1 error) *UserFindByIDExpect {
	r.r0 = r0
	r.r1 = r1
	return r
}

func (r *UserFindByIDExpect) Do(action func(a0 context.Context, a1 uint64)) *UserFindByIDExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserFindByIDExpect) OutOfOrder() *UserFindByIDExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserFindByIDExpect) AnyTimes() *UserFindByIDExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserFindByIDExpect) Times(n int) *UserFindByIDExpect {
	r.requiredTimes = n
	return r
}

func (r *UserMock) FindByID(a0 context.Context, a1 uint64) (r0 *model.User, r1 error) {
	if len(r.expect.findByID) == 0 {
		r1 = xerrors.New("cannot find mock method for User.FindByID")
		return
	}
	for _, exp := range r.expect.findByID {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			r1 = exp.r1
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r1 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		r1 = exp.r1
		return
	}
	r1 = xerrors.Errorf("invalid argument User a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *UserExpect) FindByID(a0 context.Context, a1 uint64) *UserFindByIDExpect {
	exp := &UserFindByIDExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 uint64){},
		expect:  r,
	}
	r.findByID = append(r.findByID, exp)
	return exp
}

type UserFindByIDsExpect struct {
	expect        *UserExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 []uint64)
	a0            context.Context
	a1            []uint64
	r0            *model.Users
	r1            error
}

func (r *UserFindByIDsExpect) Return(r0 *model.Users, r1 error) *UserFindByIDsExpect {
	r.r0 = r0
	r.r1 = r1
	return r
}

func (r *UserFindByIDsExpect) Do(action func(a0 context.Context, a1 []uint64)) *UserFindByIDsExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserFindByIDsExpect) OutOfOrder() *UserFindByIDsExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserFindByIDsExpect) AnyTimes() *UserFindByIDsExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserFindByIDsExpect) Times(n int) *UserFindByIDsExpect {
	r.requiredTimes = n
	return r
}

func (r *UserMock) FindByIDs(a0 context.Context, a1 []uint64) (r0 *model.Users, r1 error) {
	if len(r.expect.findByIDs) == 0 {
		r1 = xerrors.New("cannot find mock method for User.FindByIDs")
		return
	}
	for _, exp := range r.expect.findByIDs {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if len(exp.a1) != len(a1) {
			continue
		}
		if exp.isOutOfOrder {
			isMatched := func() bool {
				for _, exp := range exp.a1 {
					found := false
					for idx, act := range a1 {
						if exp != act {
							continue
						}
						a1 = append(a1[:idx], a1[idx+1:]...)
						found = true
						break
					}
					if !found {
						return false
					}
				}
				return true
			}()
			if !isMatched {
				continue
			}
		} else {
			if !reflect.DeepEqual(exp.a1, a1) {
				continue
			}
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			r1 = exp.r1
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r1 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		r1 = exp.r1
		return
	}
	r1 = xerrors.Errorf("invalid argument User a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *UserExpect) FindByIDs(a0 context.Context, a1 []uint64) *UserFindByIDsExpect {
	exp := &UserFindByIDsExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 []uint64){},
		expect:  r,
	}
	r.findByIDs = append(r.findByIDs, exp)
	return exp
}

type UserFindByNameExpect struct {
	expect        *UserExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 string)
	a0            context.Context
	a1            string
	r0            *model.User
	r1            error
}

func (r *UserFindByNameExpect) Return(r0 *model.User, r1 error) *UserFindByNameExpect {
	r.r0 = r0
	r.r1 = r1
	return r
}

func (r *UserFindByNameExpect) Do(action func(a0 context.Context, a1 string)) *UserFindByNameExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserFindByNameExpect) OutOfOrder() *UserFindByNameExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserFindByNameExpect) AnyTimes() *UserFindByNameExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserFindByNameExpect) Times(n int) *UserFindByNameExpect {
	r.requiredTimes = n
	return r
}

func (r *UserMock) FindByName(a0 context.Context, a1 string) (r0 *model.User, r1 error) {
	if len(r.expect.findByName) == 0 {
		r1 = xerrors.New("cannot find mock method for User.FindByName")
		return
	}
	for _, exp := range r.expect.findByName {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			r1 = exp.r1
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r1 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		r1 = exp.r1
		return
	}
	r1 = xerrors.Errorf("invalid argument User a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *UserExpect) FindByName(a0 context.Context, a1 string) *UserFindByNameExpect {
	exp := &UserFindByNameExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 string){},
		expect:  r,
	}
	r.findByName = append(r.findByName, exp)
	return exp
}

type UserFindByNamesExpect struct {
	expect        *UserExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 []string)
	a0            context.Context
	a1            []string
	r0            *model.Users
	r1            error
}

func (r *UserFindByNamesExpect) Return(r0 *model.Users, r1 error) *UserFindByNamesExpect {
	r.r0 = r0
	r.r1 = r1
	return r
}

func (r *UserFindByNamesExpect) Do(action func(a0 context.Context, a1 []string)) *UserFindByNamesExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserFindByNamesExpect) OutOfOrder() *UserFindByNamesExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserFindByNamesExpect) AnyTimes() *UserFindByNamesExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserFindByNamesExpect) Times(n int) *UserFindByNamesExpect {
	r.requiredTimes = n
	return r
}

func (r *UserMock) FindByNames(a0 context.Context, a1 []string) (r0 *model.Users, r1 error) {
	if len(r.expect.findByNames) == 0 {
		r1 = xerrors.New("cannot find mock method for User.FindByNames")
		return
	}
	for _, exp := range r.expect.findByNames {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if len(exp.a1) != len(a1) {
			continue
		}
		if exp.isOutOfOrder {
			isMatched := func() bool {
				for _, exp := range exp.a1 {
					found := false
					for idx, act := range a1 {
						if exp != act {
							continue
						}
						a1 = append(a1[:idx], a1[idx+1:]...)
						found = true
						break
					}
					if !found {
						return false
					}
				}
				return true
			}()
			if !isMatched {
				continue
			}
		} else {
			if !reflect.DeepEqual(exp.a1, a1) {
				continue
			}
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			r1 = exp.r1
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r1 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		r1 = exp.r1
		return
	}
	r1 = xerrors.Errorf("invalid argument User a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *UserExpect) FindByNames(a0 context.Context, a1 []string) *UserFindByNamesExpect {
	exp := &UserFindByNamesExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 []string){},
		expect:  r,
	}
	r.findByNames = append(r.findByNames, exp)
	return exp
}

type UserFindBySkillIDExpect struct {
	expect        *UserExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 uint64)
	a0            context.Context
	a1            uint64
	r0            *model.Users
	r1            error
}

func (r *UserFindBySkillIDExpect) Return(r0 *model.Users, r1 error) *UserFindBySkillIDExpect {
	r.r0 = r0
	r.r1 = r1
	return r
}

func (r *UserFindBySkillIDExpect) Do(action func(a0 context.Context, a1 uint64)) *UserFindBySkillIDExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserFindBySkillIDExpect) OutOfOrder() *UserFindBySkillIDExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserFindBySkillIDExpect) AnyTimes() *UserFindBySkillIDExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserFindBySkillIDExpect) Times(n int) *UserFindBySkillIDExpect {
	r.requiredTimes = n
	return r
}

func (r *UserMock) FindBySkillID(a0 context.Context, a1 uint64) (r0 *model.Users, r1 error) {
	if len(r.expect.findBySkillID) == 0 {
		r1 = xerrors.New("cannot find mock method for User.FindBySkillID")
		return
	}
	for _, exp := range r.expect.findBySkillID {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			r1 = exp.r1
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r1 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		r1 = exp.r1
		return
	}
	r1 = xerrors.Errorf("invalid argument User a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *UserExpect) FindBySkillID(a0 context.Context, a1 uint64) *UserFindBySkillIDExpect {
	exp := &UserFindBySkillIDExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 uint64){},
		expect:  r,
	}
	r.findBySkillID = append(r.findBySkillID, exp)
	return exp
}

type UserFindBySkillIDAndSkillRankExpect struct {
	expect        *UserExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 uint64, a2 int)
	a0            context.Context
	a1            uint64
	a2            int
	r0            *model.User
	r1            error
}

func (r *UserFindBySkillIDAndSkillRankExpect) Return(r0 *model.User, r1 error) *UserFindBySkillIDAndSkillRankExpect {
	r.r0 = r0
	r.r1 = r1
	return r
}

func (r *UserFindBySkillIDAndSkillRankExpect) Do(action func(a0 context.Context, a1 uint64, a2 int)) *UserFindBySkillIDAndSkillRankExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserFindBySkillIDAndSkillRankExpect) OutOfOrder() *UserFindBySkillIDAndSkillRankExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserFindBySkillIDAndSkillRankExpect) AnyTimes() *UserFindBySkillIDAndSkillRankExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserFindBySkillIDAndSkillRankExpect) Times(n int) *UserFindBySkillIDAndSkillRankExpect {
	r.requiredTimes = n
	return r
}

func (r *UserMock) FindBySkillIDAndSkillRank(a0 context.Context, a1 uint64, a2 int) (r0 *model.User, r1 error) {
	if len(r.expect.findBySkillIDAndSkillRank) == 0 {
		r1 = xerrors.New("cannot find mock method for User.FindBySkillIDAndSkillRank")
		return
	}
	for _, exp := range r.expect.findBySkillIDAndSkillRank {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		if !reflect.DeepEqual(exp.a2, a2) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1, a2)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			r1 = exp.r1
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r1 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		r1 = exp.r1
		return
	}
	r1 = xerrors.Errorf("invalid argument User a0:[%+v] a1:[%+v] a2:[%+v]", a0, a1, a2)
	return
}

func (r *UserExpect) FindBySkillIDAndSkillRank(a0 context.Context, a1 uint64, a2 int) *UserFindBySkillIDAndSkillRankExpect {
	exp := &UserFindBySkillIDAndSkillRankExpect{
		a0:      a0,
		a1:      a1,
		a2:      a2,
		actions: []func(a0 context.Context, a1 uint64, a2 int){},
		expect:  r,
	}
	r.findBySkillIDAndSkillRank = append(r.findBySkillIDAndSkillRank, exp)
	return exp
}

type UserFindBySkillIDsExpect struct {
	expect        *UserExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 []uint64)
	a0            context.Context
	a1            []uint64
	r0            *model.Users
	r1            error
}

func (r *UserFindBySkillIDsExpect) Return(r0 *model.Users, r1 error) *UserFindBySkillIDsExpect {
	r.r0 = r0
	r.r1 = r1
	return r
}

func (r *UserFindBySkillIDsExpect) Do(action func(a0 context.Context, a1 []uint64)) *UserFindBySkillIDsExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserFindBySkillIDsExpect) OutOfOrder() *UserFindBySkillIDsExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserFindBySkillIDsExpect) AnyTimes() *UserFindBySkillIDsExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserFindBySkillIDsExpect) Times(n int) *UserFindBySkillIDsExpect {
	r.requiredTimes = n
	return r
}

func (r *UserMock) FindBySkillIDs(a0 context.Context, a1 []uint64) (r0 *model.Users, r1 error) {
	if len(r.expect.findBySkillIDs) == 0 {
		r1 = xerrors.New("cannot find mock method for User.FindBySkillIDs")
		return
	}
	for _, exp := range r.expect.findBySkillIDs {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if len(exp.a1) != len(a1) {
			continue
		}
		if exp.isOutOfOrder {
			isMatched := func() bool {
				for _, exp := range exp.a1 {
					found := false
					for idx, act := range a1 {
						if exp != act {
							continue
						}
						a1 = append(a1[:idx], a1[idx+1:]...)
						found = true
						break
					}
					if !found {
						return false
					}
				}
				return true
			}()
			if !isMatched {
				continue
			}
		} else {
			if !reflect.DeepEqual(exp.a1, a1) {
				continue
			}
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			r1 = exp.r1
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r1 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		r1 = exp.r1
		return
	}
	r1 = xerrors.Errorf("invalid argument User a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *UserExpect) FindBySkillIDs(a0 context.Context, a1 []uint64) *UserFindBySkillIDsExpect {
	exp := &UserFindBySkillIDsExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 []uint64){},
		expect:  r,
	}
	r.findBySkillIDs = append(r.findBySkillIDs, exp)
	return exp
}

type UserFindByWorldIDExpect struct {
	expect        *UserExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 uint64)
	a0            context.Context
	a1            uint64
	r0            *model.Users
	r1            error
}

func (r *UserFindByWorldIDExpect) Return(r0 *model.Users, r1 error) *UserFindByWorldIDExpect {
	r.r0 = r0
	r.r1 = r1
	return r
}

func (r *UserFindByWorldIDExpect) Do(action func(a0 context.Context, a1 uint64)) *UserFindByWorldIDExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserFindByWorldIDExpect) OutOfOrder() *UserFindByWorldIDExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserFindByWorldIDExpect) AnyTimes() *UserFindByWorldIDExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserFindByWorldIDExpect) Times(n int) *UserFindByWorldIDExpect {
	r.requiredTimes = n
	return r
}

func (r *UserMock) FindByWorldID(a0 context.Context, a1 uint64) (r0 *model.Users, r1 error) {
	if len(r.expect.findByWorldID) == 0 {
		r1 = xerrors.New("cannot find mock method for User.FindByWorldID")
		return
	}
	for _, exp := range r.expect.findByWorldID {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			r1 = exp.r1
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r1 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		r1 = exp.r1
		return
	}
	r1 = xerrors.Errorf("invalid argument User a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *UserExpect) FindByWorldID(a0 context.Context, a1 uint64) *UserFindByWorldIDExpect {
	exp := &UserFindByWorldIDExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 uint64){},
		expect:  r,
	}
	r.findByWorldID = append(r.findByWorldID, exp)
	return exp
}

type UserFindByWorldIDAndFieldIDExpect struct {
	expect        *UserExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 uint64, a2 uint64)
	a0            context.Context
	a1            uint64
	a2            uint64
	r0            *model.Users
	r1            error
}

func (r *UserFindByWorldIDAndFieldIDExpect) Return(r0 *model.Users, r1 error) *UserFindByWorldIDAndFieldIDExpect {
	r.r0 = r0
	r.r1 = r1
	return r
}

func (r *UserFindByWorldIDAndFieldIDExpect) Do(action func(a0 context.Context, a1 uint64, a2 uint64)) *UserFindByWorldIDAndFieldIDExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserFindByWorldIDAndFieldIDExpect) OutOfOrder() *UserFindByWorldIDAndFieldIDExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserFindByWorldIDAndFieldIDExpect) AnyTimes() *UserFindByWorldIDAndFieldIDExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserFindByWorldIDAndFieldIDExpect) Times(n int) *UserFindByWorldIDAndFieldIDExpect {
	r.requiredTimes = n
	return r
}

func (r *UserMock) FindByWorldIDAndFieldID(a0 context.Context, a1 uint64, a2 uint64) (r0 *model.Users, r1 error) {
	if len(r.expect.findByWorldIDAndFieldID) == 0 {
		r1 = xerrors.New("cannot find mock method for User.FindByWorldIDAndFieldID")
		return
	}
	for _, exp := range r.expect.findByWorldIDAndFieldID {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		if !reflect.DeepEqual(exp.a2, a2) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1, a2)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			r1 = exp.r1
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r1 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		r1 = exp.r1
		return
	}
	r1 = xerrors.Errorf("invalid argument User a0:[%+v] a1:[%+v] a2:[%+v]", a0, a1, a2)
	return
}

func (r *UserExpect) FindByWorldIDAndFieldID(a0 context.Context, a1 uint64, a2 uint64) *UserFindByWorldIDAndFieldIDExpect {
	exp := &UserFindByWorldIDAndFieldIDExpect{
		a0:      a0,
		a1:      a1,
		a2:      a2,
		actions: []func(a0 context.Context, a1 uint64, a2 uint64){},
		expect:  r,
	}
	r.findByWorldIDAndFieldID = append(r.findByWorldIDAndFieldID, exp)
	return exp
}

type UserFindByWorldIDsExpect struct {
	expect        *UserExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 []uint64)
	a0            context.Context
	a1            []uint64
	r0            *model.Users
	r1            error
}

func (r *UserFindByWorldIDsExpect) Return(r0 *model.Users, r1 error) *UserFindByWorldIDsExpect {
	r.r0 = r0
	r.r1 = r1
	return r
}

func (r *UserFindByWorldIDsExpect) Do(action func(a0 context.Context, a1 []uint64)) *UserFindByWorldIDsExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserFindByWorldIDsExpect) OutOfOrder() *UserFindByWorldIDsExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserFindByWorldIDsExpect) AnyTimes() *UserFindByWorldIDsExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserFindByWorldIDsExpect) Times(n int) *UserFindByWorldIDsExpect {
	r.requiredTimes = n
	return r
}

func (r *UserMock) FindByWorldIDs(a0 context.Context, a1 []uint64) (r0 *model.Users, r1 error) {
	if len(r.expect.findByWorldIDs) == 0 {
		r1 = xerrors.New("cannot find mock method for User.FindByWorldIDs")
		return
	}
	for _, exp := range r.expect.findByWorldIDs {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if len(exp.a1) != len(a1) {
			continue
		}
		if exp.isOutOfOrder {
			isMatched := func() bool {
				for _, exp := range exp.a1 {
					found := false
					for idx, act := range a1 {
						if exp != act {
							continue
						}
						a1 = append(a1[:idx], a1[idx+1:]...)
						found = true
						break
					}
					if !found {
						return false
					}
				}
				return true
			}()
			if !isMatched {
				continue
			}
		} else {
			if !reflect.DeepEqual(exp.a1, a1) {
				continue
			}
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			r1 = exp.r1
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r1 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		r1 = exp.r1
		return
	}
	r1 = xerrors.Errorf("invalid argument User a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *UserExpect) FindByWorldIDs(a0 context.Context, a1 []uint64) *UserFindByWorldIDsExpect {
	exp := &UserFindByWorldIDsExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 []uint64){},
		expect:  r,
	}
	r.findByWorldIDs = append(r.findByWorldIDs, exp)
	return exp
}

type UserUpdateByGroupIDExpect struct {
	expect        *UserExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 uint64, a2 map[string]interface{})
	a0            context.Context
	a1            uint64
	a2            map[string]interface{}
	r0            error
}

func (r *UserUpdateByGroupIDExpect) Return(r0 error) *UserUpdateByGroupIDExpect {
	r.r0 = r0
	return r
}

func (r *UserUpdateByGroupIDExpect) Do(action func(a0 context.Context, a1 uint64, a2 map[string]interface{})) *UserUpdateByGroupIDExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserUpdateByGroupIDExpect) OutOfOrder() *UserUpdateByGroupIDExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserUpdateByGroupIDExpect) AnyTimes() *UserUpdateByGroupIDExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserUpdateByGroupIDExpect) Times(n int) *UserUpdateByGroupIDExpect {
	r.requiredTimes = n
	return r
}

func (r *UserMock) UpdateByGroupID(a0 context.Context, a1 uint64, a2 map[string]interface{}) (r0 error) {
	if len(r.expect.updateByGroupID) == 0 {
		r0 = xerrors.New("cannot find mock method for User.UpdateByGroupID")
		return
	}
	for _, exp := range r.expect.updateByGroupID {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		if !reflect.DeepEqual(exp.a2, a2) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1, a2)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument User a0:[%+v] a1:[%+v] a2:[%+v]", a0, a1, a2)
	return
}

func (r *UserExpect) UpdateByGroupID(a0 context.Context, a1 uint64, a2 map[string]interface{}) *UserUpdateByGroupIDExpect {
	exp := &UserUpdateByGroupIDExpect{
		a0:      a0,
		a1:      a1,
		a2:      a2,
		actions: []func(a0 context.Context, a1 uint64, a2 map[string]interface{}){},
		expect:  r,
	}
	r.updateByGroupID = append(r.updateByGroupID, exp)
	return exp
}

type UserUpdateByGroupIDsExpect struct {
	expect        *UserExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 []uint64, a2 map[string]interface{})
	a0            context.Context
	a1            []uint64
	a2            map[string]interface{}
	r0            error
}

func (r *UserUpdateByGroupIDsExpect) Return(r0 error) *UserUpdateByGroupIDsExpect {
	r.r0 = r0
	return r
}

func (r *UserUpdateByGroupIDsExpect) Do(action func(a0 context.Context, a1 []uint64, a2 map[string]interface{})) *UserUpdateByGroupIDsExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserUpdateByGroupIDsExpect) OutOfOrder() *UserUpdateByGroupIDsExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserUpdateByGroupIDsExpect) AnyTimes() *UserUpdateByGroupIDsExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserUpdateByGroupIDsExpect) Times(n int) *UserUpdateByGroupIDsExpect {
	r.requiredTimes = n
	return r
}

func (r *UserMock) UpdateByGroupIDs(a0 context.Context, a1 []uint64, a2 map[string]interface{}) (r0 error) {
	if len(r.expect.updateByGroupIDs) == 0 {
		r0 = xerrors.New("cannot find mock method for User.UpdateByGroupIDs")
		return
	}
	for _, exp := range r.expect.updateByGroupIDs {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if len(exp.a1) != len(a1) {
			continue
		}
		if exp.isOutOfOrder {
			isMatched := func() bool {
				for _, exp := range exp.a1 {
					found := false
					for idx, act := range a1 {
						if exp != act {
							continue
						}
						a1 = append(a1[:idx], a1[idx+1:]...)
						found = true
						break
					}
					if !found {
						return false
					}
				}
				return true
			}()
			if !isMatched {
				continue
			}
		} else {
			if !reflect.DeepEqual(exp.a1, a1) {
				continue
			}
		}
		if !reflect.DeepEqual(exp.a2, a2) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1, a2)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument User a0:[%+v] a1:[%+v] a2:[%+v]", a0, a1, a2)
	return
}

func (r *UserExpect) UpdateByGroupIDs(a0 context.Context, a1 []uint64, a2 map[string]interface{}) *UserUpdateByGroupIDsExpect {
	exp := &UserUpdateByGroupIDsExpect{
		a0:      a0,
		a1:      a1,
		a2:      a2,
		actions: []func(a0 context.Context, a1 []uint64, a2 map[string]interface{}){},
		expect:  r,
	}
	r.updateByGroupIDs = append(r.updateByGroupIDs, exp)
	return exp
}

type UserUpdateByIDExpect struct {
	expect        *UserExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 uint64, a2 map[string]interface{})
	a0            context.Context
	a1            uint64
	a2            map[string]interface{}
	r0            error
}

func (r *UserUpdateByIDExpect) Return(r0 error) *UserUpdateByIDExpect {
	r.r0 = r0
	return r
}

func (r *UserUpdateByIDExpect) Do(action func(a0 context.Context, a1 uint64, a2 map[string]interface{})) *UserUpdateByIDExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserUpdateByIDExpect) OutOfOrder() *UserUpdateByIDExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserUpdateByIDExpect) AnyTimes() *UserUpdateByIDExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserUpdateByIDExpect) Times(n int) *UserUpdateByIDExpect {
	r.requiredTimes = n
	return r
}

func (r *UserMock) UpdateByID(a0 context.Context, a1 uint64, a2 map[string]interface{}) (r0 error) {
	if len(r.expect.updateByID) == 0 {
		r0 = xerrors.New("cannot find mock method for User.UpdateByID")
		return
	}
	for _, exp := range r.expect.updateByID {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		if !reflect.DeepEqual(exp.a2, a2) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1, a2)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument User a0:[%+v] a1:[%+v] a2:[%+v]", a0, a1, a2)
	return
}

func (r *UserExpect) UpdateByID(a0 context.Context, a1 uint64, a2 map[string]interface{}) *UserUpdateByIDExpect {
	exp := &UserUpdateByIDExpect{
		a0:      a0,
		a1:      a1,
		a2:      a2,
		actions: []func(a0 context.Context, a1 uint64, a2 map[string]interface{}){},
		expect:  r,
	}
	r.updateByID = append(r.updateByID, exp)
	return exp
}

type UserUpdateByIDsExpect struct {
	expect        *UserExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 []uint64, a2 map[string]interface{})
	a0            context.Context
	a1            []uint64
	a2            map[string]interface{}
	r0            error
}

func (r *UserUpdateByIDsExpect) Return(r0 error) *UserUpdateByIDsExpect {
	r.r0 = r0
	return r
}

func (r *UserUpdateByIDsExpect) Do(action func(a0 context.Context, a1 []uint64, a2 map[string]interface{})) *UserUpdateByIDsExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserUpdateByIDsExpect) OutOfOrder() *UserUpdateByIDsExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserUpdateByIDsExpect) AnyTimes() *UserUpdateByIDsExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserUpdateByIDsExpect) Times(n int) *UserUpdateByIDsExpect {
	r.requiredTimes = n
	return r
}

func (r *UserMock) UpdateByIDs(a0 context.Context, a1 []uint64, a2 map[string]interface{}) (r0 error) {
	if len(r.expect.updateByIDs) == 0 {
		r0 = xerrors.New("cannot find mock method for User.UpdateByIDs")
		return
	}
	for _, exp := range r.expect.updateByIDs {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if len(exp.a1) != len(a1) {
			continue
		}
		if exp.isOutOfOrder {
			isMatched := func() bool {
				for _, exp := range exp.a1 {
					found := false
					for idx, act := range a1 {
						if exp != act {
							continue
						}
						a1 = append(a1[:idx], a1[idx+1:]...)
						found = true
						break
					}
					if !found {
						return false
					}
				}
				return true
			}()
			if !isMatched {
				continue
			}
		} else {
			if !reflect.DeepEqual(exp.a1, a1) {
				continue
			}
		}
		if !reflect.DeepEqual(exp.a2, a2) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1, a2)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument User a0:[%+v] a1:[%+v] a2:[%+v]", a0, a1, a2)
	return
}

func (r *UserExpect) UpdateByIDs(a0 context.Context, a1 []uint64, a2 map[string]interface{}) *UserUpdateByIDsExpect {
	exp := &UserUpdateByIDsExpect{
		a0:      a0,
		a1:      a1,
		a2:      a2,
		actions: []func(a0 context.Context, a1 []uint64, a2 map[string]interface{}){},
		expect:  r,
	}
	r.updateByIDs = append(r.updateByIDs, exp)
	return exp
}

type UserUpdateByNameExpect struct {
	expect        *UserExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 string, a2 map[string]interface{})
	a0            context.Context
	a1            string
	a2            map[string]interface{}
	r0            error
}

func (r *UserUpdateByNameExpect) Return(r0 error) *UserUpdateByNameExpect {
	r.r0 = r0
	return r
}

func (r *UserUpdateByNameExpect) Do(action func(a0 context.Context, a1 string, a2 map[string]interface{})) *UserUpdateByNameExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserUpdateByNameExpect) OutOfOrder() *UserUpdateByNameExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserUpdateByNameExpect) AnyTimes() *UserUpdateByNameExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserUpdateByNameExpect) Times(n int) *UserUpdateByNameExpect {
	r.requiredTimes = n
	return r
}

func (r *UserMock) UpdateByName(a0 context.Context, a1 string, a2 map[string]interface{}) (r0 error) {
	if len(r.expect.updateByName) == 0 {
		r0 = xerrors.New("cannot find mock method for User.UpdateByName")
		return
	}
	for _, exp := range r.expect.updateByName {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		if !reflect.DeepEqual(exp.a2, a2) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1, a2)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument User a0:[%+v] a1:[%+v] a2:[%+v]", a0, a1, a2)
	return
}

func (r *UserExpect) UpdateByName(a0 context.Context, a1 string, a2 map[string]interface{}) *UserUpdateByNameExpect {
	exp := &UserUpdateByNameExpect{
		a0:      a0,
		a1:      a1,
		a2:      a2,
		actions: []func(a0 context.Context, a1 string, a2 map[string]interface{}){},
		expect:  r,
	}
	r.updateByName = append(r.updateByName, exp)
	return exp
}

type UserUpdateByNamesExpect struct {
	expect        *UserExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 []string, a2 map[string]interface{})
	a0            context.Context
	a1            []string
	a2            map[string]interface{}
	r0            error
}

func (r *UserUpdateByNamesExpect) Return(r0 error) *UserUpdateByNamesExpect {
	r.r0 = r0
	return r
}

func (r *UserUpdateByNamesExpect) Do(action func(a0 context.Context, a1 []string, a2 map[string]interface{})) *UserUpdateByNamesExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserUpdateByNamesExpect) OutOfOrder() *UserUpdateByNamesExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserUpdateByNamesExpect) AnyTimes() *UserUpdateByNamesExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserUpdateByNamesExpect) Times(n int) *UserUpdateByNamesExpect {
	r.requiredTimes = n
	return r
}

func (r *UserMock) UpdateByNames(a0 context.Context, a1 []string, a2 map[string]interface{}) (r0 error) {
	if len(r.expect.updateByNames) == 0 {
		r0 = xerrors.New("cannot find mock method for User.UpdateByNames")
		return
	}
	for _, exp := range r.expect.updateByNames {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if len(exp.a1) != len(a1) {
			continue
		}
		if exp.isOutOfOrder {
			isMatched := func() bool {
				for _, exp := range exp.a1 {
					found := false
					for idx, act := range a1 {
						if exp != act {
							continue
						}
						a1 = append(a1[:idx], a1[idx+1:]...)
						found = true
						break
					}
					if !found {
						return false
					}
				}
				return true
			}()
			if !isMatched {
				continue
			}
		} else {
			if !reflect.DeepEqual(exp.a1, a1) {
				continue
			}
		}
		if !reflect.DeepEqual(exp.a2, a2) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1, a2)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument User a0:[%+v] a1:[%+v] a2:[%+v]", a0, a1, a2)
	return
}

func (r *UserExpect) UpdateByNames(a0 context.Context, a1 []string, a2 map[string]interface{}) *UserUpdateByNamesExpect {
	exp := &UserUpdateByNamesExpect{
		a0:      a0,
		a1:      a1,
		a2:      a2,
		actions: []func(a0 context.Context, a1 []string, a2 map[string]interface{}){},
		expect:  r,
	}
	r.updateByNames = append(r.updateByNames, exp)
	return exp
}

type UserUpdateBySkillIDAndSkillRankExpect struct {
	expect        *UserExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 uint64, a2 int, a3 map[string]interface{})
	a0            context.Context
	a1            uint64
	a2            int
	a3            map[string]interface{}
	r0            error
}

func (r *UserUpdateBySkillIDAndSkillRankExpect) Return(r0 error) *UserUpdateBySkillIDAndSkillRankExpect {
	r.r0 = r0
	return r
}

func (r *UserUpdateBySkillIDAndSkillRankExpect) Do(action func(a0 context.Context, a1 uint64, a2 int, a3 map[string]interface{})) *UserUpdateBySkillIDAndSkillRankExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserUpdateBySkillIDAndSkillRankExpect) OutOfOrder() *UserUpdateBySkillIDAndSkillRankExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserUpdateBySkillIDAndSkillRankExpect) AnyTimes() *UserUpdateBySkillIDAndSkillRankExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserUpdateBySkillIDAndSkillRankExpect) Times(n int) *UserUpdateBySkillIDAndSkillRankExpect {
	r.requiredTimes = n
	return r
}

func (r *UserMock) UpdateBySkillIDAndSkillRank(a0 context.Context, a1 uint64, a2 int, a3 map[string]interface{}) (r0 error) {
	if len(r.expect.updateBySkillIDAndSkillRank) == 0 {
		r0 = xerrors.New("cannot find mock method for User.UpdateBySkillIDAndSkillRank")
		return
	}
	for _, exp := range r.expect.updateBySkillIDAndSkillRank {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		if !reflect.DeepEqual(exp.a2, a2) {
			continue
		}
		if !reflect.DeepEqual(exp.a3, a3) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1, a2, a3)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument User a0:[%+v] a1:[%+v] a2:[%+v] a3:[%+v]", a0, a1, a2, a3)
	return
}

func (r *UserExpect) UpdateBySkillIDAndSkillRank(a0 context.Context, a1 uint64, a2 int, a3 map[string]interface{}) *UserUpdateBySkillIDAndSkillRankExpect {
	exp := &UserUpdateBySkillIDAndSkillRankExpect{
		a0:      a0,
		a1:      a1,
		a2:      a2,
		a3:      a3,
		actions: []func(a0 context.Context, a1 uint64, a2 int, a3 map[string]interface{}){},
		expect:  r,
	}
	r.updateBySkillIDAndSkillRank = append(r.updateBySkillIDAndSkillRank, exp)
	return exp
}

type UserUpdateByWorldIDAndFieldIDExpect struct {
	expect        *UserExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 uint64, a2 uint64, a3 map[string]interface{})
	a0            context.Context
	a1            uint64
	a2            uint64
	a3            map[string]interface{}
	r0            error
}

func (r *UserUpdateByWorldIDAndFieldIDExpect) Return(r0 error) *UserUpdateByWorldIDAndFieldIDExpect {
	r.r0 = r0
	return r
}

func (r *UserUpdateByWorldIDAndFieldIDExpect) Do(action func(a0 context.Context, a1 uint64, a2 uint64, a3 map[string]interface{})) *UserUpdateByWorldIDAndFieldIDExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserUpdateByWorldIDAndFieldIDExpect) OutOfOrder() *UserUpdateByWorldIDAndFieldIDExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserUpdateByWorldIDAndFieldIDExpect) AnyTimes() *UserUpdateByWorldIDAndFieldIDExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserUpdateByWorldIDAndFieldIDExpect) Times(n int) *UserUpdateByWorldIDAndFieldIDExpect {
	r.requiredTimes = n
	return r
}

func (r *UserMock) UpdateByWorldIDAndFieldID(a0 context.Context, a1 uint64, a2 uint64, a3 map[string]interface{}) (r0 error) {
	if len(r.expect.updateByWorldIDAndFieldID) == 0 {
		r0 = xerrors.New("cannot find mock method for User.UpdateByWorldIDAndFieldID")
		return
	}
	for _, exp := range r.expect.updateByWorldIDAndFieldID {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		if !reflect.DeepEqual(exp.a2, a2) {
			continue
		}
		if !reflect.DeepEqual(exp.a3, a3) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1, a2, a3)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument User a0:[%+v] a1:[%+v] a2:[%+v] a3:[%+v]", a0, a1, a2, a3)
	return
}

func (r *UserExpect) UpdateByWorldIDAndFieldID(a0 context.Context, a1 uint64, a2 uint64, a3 map[string]interface{}) *UserUpdateByWorldIDAndFieldIDExpect {
	exp := &UserUpdateByWorldIDAndFieldIDExpect{
		a0:      a0,
		a1:      a1,
		a2:      a2,
		a3:      a3,
		actions: []func(a0 context.Context, a1 uint64, a2 uint64, a3 map[string]interface{}){},
		expect:  r,
	}
	r.updateByWorldIDAndFieldID = append(r.updateByWorldIDAndFieldID, exp)
	return exp
}

type UserDeleteByGroupIDExpect struct {
	expect        *UserExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 uint64)
	a0            context.Context
	a1            uint64
	r0            error
}

func (r *UserDeleteByGroupIDExpect) Return(r0 error) *UserDeleteByGroupIDExpect {
	r.r0 = r0
	return r
}

func (r *UserDeleteByGroupIDExpect) Do(action func(a0 context.Context, a1 uint64)) *UserDeleteByGroupIDExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserDeleteByGroupIDExpect) OutOfOrder() *UserDeleteByGroupIDExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserDeleteByGroupIDExpect) AnyTimes() *UserDeleteByGroupIDExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserDeleteByGroupIDExpect) Times(n int) *UserDeleteByGroupIDExpect {
	r.requiredTimes = n
	return r
}

func (r *UserMock) DeleteByGroupID(a0 context.Context, a1 uint64) (r0 error) {
	if len(r.expect.deleteByGroupID) == 0 {
		r0 = xerrors.New("cannot find mock method for User.DeleteByGroupID")
		return
	}
	for _, exp := range r.expect.deleteByGroupID {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument User a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *UserExpect) DeleteByGroupID(a0 context.Context, a1 uint64) *UserDeleteByGroupIDExpect {
	exp := &UserDeleteByGroupIDExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 uint64){},
		expect:  r,
	}
	r.deleteByGroupID = append(r.deleteByGroupID, exp)
	return exp
}

type UserDeleteByGroupIDsExpect struct {
	expect        *UserExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 []uint64)
	a0            context.Context
	a1            []uint64
	r0            error
}

func (r *UserDeleteByGroupIDsExpect) Return(r0 error) *UserDeleteByGroupIDsExpect {
	r.r0 = r0
	return r
}

func (r *UserDeleteByGroupIDsExpect) Do(action func(a0 context.Context, a1 []uint64)) *UserDeleteByGroupIDsExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserDeleteByGroupIDsExpect) OutOfOrder() *UserDeleteByGroupIDsExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserDeleteByGroupIDsExpect) AnyTimes() *UserDeleteByGroupIDsExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserDeleteByGroupIDsExpect) Times(n int) *UserDeleteByGroupIDsExpect {
	r.requiredTimes = n
	return r
}

func (r *UserMock) DeleteByGroupIDs(a0 context.Context, a1 []uint64) (r0 error) {
	if len(r.expect.deleteByGroupIDs) == 0 {
		r0 = xerrors.New("cannot find mock method for User.DeleteByGroupIDs")
		return
	}
	for _, exp := range r.expect.deleteByGroupIDs {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if len(exp.a1) != len(a1) {
			continue
		}
		if exp.isOutOfOrder {
			isMatched := func() bool {
				for _, exp := range exp.a1 {
					found := false
					for idx, act := range a1 {
						if exp != act {
							continue
						}
						a1 = append(a1[:idx], a1[idx+1:]...)
						found = true
						break
					}
					if !found {
						return false
					}
				}
				return true
			}()
			if !isMatched {
				continue
			}
		} else {
			if !reflect.DeepEqual(exp.a1, a1) {
				continue
			}
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument User a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *UserExpect) DeleteByGroupIDs(a0 context.Context, a1 []uint64) *UserDeleteByGroupIDsExpect {
	exp := &UserDeleteByGroupIDsExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 []uint64){},
		expect:  r,
	}
	r.deleteByGroupIDs = append(r.deleteByGroupIDs, exp)
	return exp
}

type UserDeleteByIDExpect struct {
	expect        *UserExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 uint64)
	a0            context.Context
	a1            uint64
	r0            error
}

func (r *UserDeleteByIDExpect) Return(r0 error) *UserDeleteByIDExpect {
	r.r0 = r0
	return r
}

func (r *UserDeleteByIDExpect) Do(action func(a0 context.Context, a1 uint64)) *UserDeleteByIDExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserDeleteByIDExpect) OutOfOrder() *UserDeleteByIDExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserDeleteByIDExpect) AnyTimes() *UserDeleteByIDExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserDeleteByIDExpect) Times(n int) *UserDeleteByIDExpect {
	r.requiredTimes = n
	return r
}

func (r *UserMock) DeleteByID(a0 context.Context, a1 uint64) (r0 error) {
	if len(r.expect.deleteByID) == 0 {
		r0 = xerrors.New("cannot find mock method for User.DeleteByID")
		return
	}
	for _, exp := range r.expect.deleteByID {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument User a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *UserExpect) DeleteByID(a0 context.Context, a1 uint64) *UserDeleteByIDExpect {
	exp := &UserDeleteByIDExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 uint64){},
		expect:  r,
	}
	r.deleteByID = append(r.deleteByID, exp)
	return exp
}

type UserDeleteByIDsExpect struct {
	expect        *UserExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 []uint64)
	a0            context.Context
	a1            []uint64
	r0            error
}

func (r *UserDeleteByIDsExpect) Return(r0 error) *UserDeleteByIDsExpect {
	r.r0 = r0
	return r
}

func (r *UserDeleteByIDsExpect) Do(action func(a0 context.Context, a1 []uint64)) *UserDeleteByIDsExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserDeleteByIDsExpect) OutOfOrder() *UserDeleteByIDsExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserDeleteByIDsExpect) AnyTimes() *UserDeleteByIDsExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserDeleteByIDsExpect) Times(n int) *UserDeleteByIDsExpect {
	r.requiredTimes = n
	return r
}

func (r *UserMock) DeleteByIDs(a0 context.Context, a1 []uint64) (r0 error) {
	if len(r.expect.deleteByIDs) == 0 {
		r0 = xerrors.New("cannot find mock method for User.DeleteByIDs")
		return
	}
	for _, exp := range r.expect.deleteByIDs {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if len(exp.a1) != len(a1) {
			continue
		}
		if exp.isOutOfOrder {
			isMatched := func() bool {
				for _, exp := range exp.a1 {
					found := false
					for idx, act := range a1 {
						if exp != act {
							continue
						}
						a1 = append(a1[:idx], a1[idx+1:]...)
						found = true
						break
					}
					if !found {
						return false
					}
				}
				return true
			}()
			if !isMatched {
				continue
			}
		} else {
			if !reflect.DeepEqual(exp.a1, a1) {
				continue
			}
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument User a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *UserExpect) DeleteByIDs(a0 context.Context, a1 []uint64) *UserDeleteByIDsExpect {
	exp := &UserDeleteByIDsExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 []uint64){},
		expect:  r,
	}
	r.deleteByIDs = append(r.deleteByIDs, exp)
	return exp
}

type UserDeleteByNameExpect struct {
	expect        *UserExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 string)
	a0            context.Context
	a1            string
	r0            error
}

func (r *UserDeleteByNameExpect) Return(r0 error) *UserDeleteByNameExpect {
	r.r0 = r0
	return r
}

func (r *UserDeleteByNameExpect) Do(action func(a0 context.Context, a1 string)) *UserDeleteByNameExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserDeleteByNameExpect) OutOfOrder() *UserDeleteByNameExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserDeleteByNameExpect) AnyTimes() *UserDeleteByNameExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserDeleteByNameExpect) Times(n int) *UserDeleteByNameExpect {
	r.requiredTimes = n
	return r
}

func (r *UserMock) DeleteByName(a0 context.Context, a1 string) (r0 error) {
	if len(r.expect.deleteByName) == 0 {
		r0 = xerrors.New("cannot find mock method for User.DeleteByName")
		return
	}
	for _, exp := range r.expect.deleteByName {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument User a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *UserExpect) DeleteByName(a0 context.Context, a1 string) *UserDeleteByNameExpect {
	exp := &UserDeleteByNameExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 string){},
		expect:  r,
	}
	r.deleteByName = append(r.deleteByName, exp)
	return exp
}

type UserDeleteByNamesExpect struct {
	expect        *UserExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 []string)
	a0            context.Context
	a1            []string
	r0            error
}

func (r *UserDeleteByNamesExpect) Return(r0 error) *UserDeleteByNamesExpect {
	r.r0 = r0
	return r
}

func (r *UserDeleteByNamesExpect) Do(action func(a0 context.Context, a1 []string)) *UserDeleteByNamesExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserDeleteByNamesExpect) OutOfOrder() *UserDeleteByNamesExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserDeleteByNamesExpect) AnyTimes() *UserDeleteByNamesExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserDeleteByNamesExpect) Times(n int) *UserDeleteByNamesExpect {
	r.requiredTimes = n
	return r
}

func (r *UserMock) DeleteByNames(a0 context.Context, a1 []string) (r0 error) {
	if len(r.expect.deleteByNames) == 0 {
		r0 = xerrors.New("cannot find mock method for User.DeleteByNames")
		return
	}
	for _, exp := range r.expect.deleteByNames {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if len(exp.a1) != len(a1) {
			continue
		}
		if exp.isOutOfOrder {
			isMatched := func() bool {
				for _, exp := range exp.a1 {
					found := false
					for idx, act := range a1 {
						if exp != act {
							continue
						}
						a1 = append(a1[:idx], a1[idx+1:]...)
						found = true
						break
					}
					if !found {
						return false
					}
				}
				return true
			}()
			if !isMatched {
				continue
			}
		} else {
			if !reflect.DeepEqual(exp.a1, a1) {
				continue
			}
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument User a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *UserExpect) DeleteByNames(a0 context.Context, a1 []string) *UserDeleteByNamesExpect {
	exp := &UserDeleteByNamesExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 []string){},
		expect:  r,
	}
	r.deleteByNames = append(r.deleteByNames, exp)
	return exp
}

type UserDeleteBySkillIDAndSkillRankExpect struct {
	expect        *UserExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 uint64, a2 int)
	a0            context.Context
	a1            uint64
	a2            int
	r0            error
}

func (r *UserDeleteBySkillIDAndSkillRankExpect) Return(r0 error) *UserDeleteBySkillIDAndSkillRankExpect {
	r.r0 = r0
	return r
}

func (r *UserDeleteBySkillIDAndSkillRankExpect) Do(action func(a0 context.Context, a1 uint64, a2 int)) *UserDeleteBySkillIDAndSkillRankExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserDeleteBySkillIDAndSkillRankExpect) OutOfOrder() *UserDeleteBySkillIDAndSkillRankExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserDeleteBySkillIDAndSkillRankExpect) AnyTimes() *UserDeleteBySkillIDAndSkillRankExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserDeleteBySkillIDAndSkillRankExpect) Times(n int) *UserDeleteBySkillIDAndSkillRankExpect {
	r.requiredTimes = n
	return r
}

func (r *UserMock) DeleteBySkillIDAndSkillRank(a0 context.Context, a1 uint64, a2 int) (r0 error) {
	if len(r.expect.deleteBySkillIDAndSkillRank) == 0 {
		r0 = xerrors.New("cannot find mock method for User.DeleteBySkillIDAndSkillRank")
		return
	}
	for _, exp := range r.expect.deleteBySkillIDAndSkillRank {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		if !reflect.DeepEqual(exp.a2, a2) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1, a2)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument User a0:[%+v] a1:[%+v] a2:[%+v]", a0, a1, a2)
	return
}

func (r *UserExpect) DeleteBySkillIDAndSkillRank(a0 context.Context, a1 uint64, a2 int) *UserDeleteBySkillIDAndSkillRankExpect {
	exp := &UserDeleteBySkillIDAndSkillRankExpect{
		a0:      a0,
		a1:      a1,
		a2:      a2,
		actions: []func(a0 context.Context, a1 uint64, a2 int){},
		expect:  r,
	}
	r.deleteBySkillIDAndSkillRank = append(r.deleteBySkillIDAndSkillRank, exp)
	return exp
}

type UserDeleteByWorldIDAndFieldIDExpect struct {
	expect        *UserExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 uint64, a2 uint64)
	a0            context.Context
	a1            uint64
	a2            uint64
	r0            error
}

func (r *UserDeleteByWorldIDAndFieldIDExpect) Return(r0 error) *UserDeleteByWorldIDAndFieldIDExpect {
	r.r0 = r0
	return r
}

func (r *UserDeleteByWorldIDAndFieldIDExpect) Do(action func(a0 context.Context, a1 uint64, a2 uint64)) *UserDeleteByWorldIDAndFieldIDExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserDeleteByWorldIDAndFieldIDExpect) OutOfOrder() *UserDeleteByWorldIDAndFieldIDExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserDeleteByWorldIDAndFieldIDExpect) AnyTimes() *UserDeleteByWorldIDAndFieldIDExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserDeleteByWorldIDAndFieldIDExpect) Times(n int) *UserDeleteByWorldIDAndFieldIDExpect {
	r.requiredTimes = n
	return r
}

func (r *UserMock) DeleteByWorldIDAndFieldID(a0 context.Context, a1 uint64, a2 uint64) (r0 error) {
	if len(r.expect.deleteByWorldIDAndFieldID) == 0 {
		r0 = xerrors.New("cannot find mock method for User.DeleteByWorldIDAndFieldID")
		return
	}
	for _, exp := range r.expect.deleteByWorldIDAndFieldID {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		if !reflect.DeepEqual(exp.a2, a2) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1, a2)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument User a0:[%+v] a1:[%+v] a2:[%+v]", a0, a1, a2)
	return
}

func (r *UserExpect) DeleteByWorldIDAndFieldID(a0 context.Context, a1 uint64, a2 uint64) *UserDeleteByWorldIDAndFieldIDExpect {
	exp := &UserDeleteByWorldIDAndFieldIDExpect{
		a0:      a0,
		a1:      a1,
		a2:      a2,
		actions: []func(a0 context.Context, a1 uint64, a2 uint64){},
		expect:  r,
	}
	r.deleteByWorldIDAndFieldID = append(r.deleteByWorldIDAndFieldID, exp)
	return exp
}

type UserCountExpect struct {
	expect        *UserExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context)
	a0            context.Context
	r0            int64
	r1            error
}

func (r *UserCountExpect) Return(r0 int64, r1 error) *UserCountExpect {
	r.r0 = r0
	r.r1 = r1
	return r
}

func (r *UserCountExpect) Do(action func(a0 context.Context)) *UserCountExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserCountExpect) OutOfOrder() *UserCountExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserCountExpect) AnyTimes() *UserCountExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserCountExpect) Times(n int) *UserCountExpect {
	r.requiredTimes = n
	return r
}

func (r *UserMock) Count(a0 context.Context) (r0 int64, r1 error) {
	if len(r.expect.count) == 0 {
		r1 = xerrors.New("cannot find mock method for User.Count")
		return
	}
	for _, exp := range r.expect.count {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		for _, action := range exp.actions {
			action(a0)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			r1 = exp.r1
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r1 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		r1 = exp.r1
		return
	}
	r1 = xerrors.Errorf("invalid argument User a0:[%+v]", a0)
	return
}

func (r *UserExpect) Count(a0 context.Context) *UserCountExpect {
	exp := &UserCountExpect{
		a0:      a0,
		actions: []func(a0 context.Context){},
		expect:  r,
	}
	r.count = append(r.count, exp)
	return exp
}

type UserDeleteExpect struct {
	expect        *UserExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 *entity.User)
	a0            context.Context
	a1            *entity.User
	r0            error
}

func (r *UserDeleteExpect) Return(r0 error) *UserDeleteExpect {
	r.r0 = r0
	return r
}

func (r *UserDeleteExpect) Do(action func(a0 context.Context, a1 *entity.User)) *UserDeleteExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserDeleteExpect) OutOfOrder() *UserDeleteExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserDeleteExpect) AnyTimes() *UserDeleteExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserDeleteExpect) Times(n int) *UserDeleteExpect {
	r.requiredTimes = n
	return r
}

func (r *UserMock) Delete(a0 context.Context, a1 *entity.User) (r0 error) {
	if len(r.expect.delete) == 0 {
		r0 = xerrors.New("cannot find mock method for User.Delete")
		return
	}
	for _, exp := range r.expect.delete {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument User a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *UserExpect) Delete(a0 context.Context, a1 *entity.User) *UserDeleteExpect {
	exp := &UserDeleteExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 *entity.User){},
		expect:  r,
	}
	r.delete = append(r.delete, exp)
	return exp
}

type UserUpdateExpect struct {
	expect        *UserExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 *entity.User)
	a0            context.Context
	a1            *entity.User
	r0            error
}

func (r *UserUpdateExpect) Return(r0 error) *UserUpdateExpect {
	r.r0 = r0
	return r
}

func (r *UserUpdateExpect) Do(action func(a0 context.Context, a1 *entity.User)) *UserUpdateExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserUpdateExpect) OutOfOrder() *UserUpdateExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserUpdateExpect) AnyTimes() *UserUpdateExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserUpdateExpect) Times(n int) *UserUpdateExpect {
	r.requiredTimes = n
	return r
}

func (r *UserMock) Update(a0 context.Context, a1 *entity.User) (r0 error) {
	if len(r.expect.update) == 0 {
		r0 = xerrors.New("cannot find mock method for User.Update")
		return
	}
	for _, exp := range r.expect.update {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument User a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *UserExpect) Update(a0 context.Context, a1 *entity.User) *UserUpdateExpect {
	exp := &UserUpdateExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 *entity.User){},
		expect:  r,
	}
	r.update = append(r.update, exp)
	return exp
}

type UserExpect struct {
	toModel                     []*UserToModelExpect
	toModels                    []*UserToModelsExpect
	create                      []*UserCreateExpect
	creates                     []*UserCreatesExpect
	findAll                     []*UserFindAllExpect
	findByGroupID               []*UserFindByGroupIDExpect
	findByGroupIDs              []*UserFindByGroupIDsExpect
	findByID                    []*UserFindByIDExpect
	findByIDs                   []*UserFindByIDsExpect
	findByName                  []*UserFindByNameExpect
	findByNames                 []*UserFindByNamesExpect
	findBySkillID               []*UserFindBySkillIDExpect
	findBySkillIDAndSkillRank   []*UserFindBySkillIDAndSkillRankExpect
	findBySkillIDs              []*UserFindBySkillIDsExpect
	findByWorldID               []*UserFindByWorldIDExpect
	findByWorldIDAndFieldID     []*UserFindByWorldIDAndFieldIDExpect
	findByWorldIDs              []*UserFindByWorldIDsExpect
	updateByGroupID             []*UserUpdateByGroupIDExpect
	updateByGroupIDs            []*UserUpdateByGroupIDsExpect
	updateByID                  []*UserUpdateByIDExpect
	updateByIDs                 []*UserUpdateByIDsExpect
	updateByName                []*UserUpdateByNameExpect
	updateByNames               []*UserUpdateByNamesExpect
	updateBySkillIDAndSkillRank []*UserUpdateBySkillIDAndSkillRankExpect
	updateByWorldIDAndFieldID   []*UserUpdateByWorldIDAndFieldIDExpect
	deleteByGroupID             []*UserDeleteByGroupIDExpect
	deleteByGroupIDs            []*UserDeleteByGroupIDsExpect
	deleteByID                  []*UserDeleteByIDExpect
	deleteByIDs                 []*UserDeleteByIDsExpect
	deleteByName                []*UserDeleteByNameExpect
	deleteByNames               []*UserDeleteByNamesExpect
	deleteBySkillIDAndSkillRank []*UserDeleteBySkillIDAndSkillRankExpect
	deleteByWorldIDAndFieldID   []*UserDeleteByWorldIDAndFieldIDExpect
	count                       []*UserCountExpect
	delete                      []*UserDeleteExpect
	update                      []*UserUpdateExpect
}

func NewUserExpect() *UserExpect {
	return &UserExpect{
		count:                       []*UserCountExpect{},
		create:                      []*UserCreateExpect{},
		creates:                     []*UserCreatesExpect{},
		delete:                      []*UserDeleteExpect{},
		deleteByGroupID:             []*UserDeleteByGroupIDExpect{},
		deleteByGroupIDs:            []*UserDeleteByGroupIDsExpect{},
		deleteByID:                  []*UserDeleteByIDExpect{},
		deleteByIDs:                 []*UserDeleteByIDsExpect{},
		deleteByName:                []*UserDeleteByNameExpect{},
		deleteByNames:               []*UserDeleteByNamesExpect{},
		deleteBySkillIDAndSkillRank: []*UserDeleteBySkillIDAndSkillRankExpect{},
		deleteByWorldIDAndFieldID:   []*UserDeleteByWorldIDAndFieldIDExpect{},
		findAll:                     []*UserFindAllExpect{},
		findByGroupID:               []*UserFindByGroupIDExpect{},
		findByGroupIDs:              []*UserFindByGroupIDsExpect{},
		findByID:                    []*UserFindByIDExpect{},
		findByIDs:                   []*UserFindByIDsExpect{},
		findByName:                  []*UserFindByNameExpect{},
		findByNames:                 []*UserFindByNamesExpect{},
		findBySkillID:               []*UserFindBySkillIDExpect{},
		findBySkillIDAndSkillRank:   []*UserFindBySkillIDAndSkillRankExpect{},
		findBySkillIDs:              []*UserFindBySkillIDsExpect{},
		findByWorldID:               []*UserFindByWorldIDExpect{},
		findByWorldIDAndFieldID:     []*UserFindByWorldIDAndFieldIDExpect{},
		findByWorldIDs:              []*UserFindByWorldIDsExpect{},
		toModel:                     []*UserToModelExpect{},
		toModels:                    []*UserToModelsExpect{},
		update:                      []*UserUpdateExpect{},
		updateByGroupID:             []*UserUpdateByGroupIDExpect{},
		updateByGroupIDs:            []*UserUpdateByGroupIDsExpect{},
		updateByID:                  []*UserUpdateByIDExpect{},
		updateByIDs:                 []*UserUpdateByIDsExpect{},
		updateByName:                []*UserUpdateByNameExpect{},
		updateByNames:               []*UserUpdateByNamesExpect{},
		updateBySkillIDAndSkillRank: []*UserUpdateBySkillIDAndSkillRankExpect{},
		updateByWorldIDAndFieldID:   []*UserUpdateByWorldIDAndFieldIDExpect{},
	}
}
