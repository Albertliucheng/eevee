// Code generated by eevee. DO NOT EDIT!

package model

import (
	"context"
	"relation/entity"
)

type ModelConverter interface {
	ToField(*entity.Field) *Field
	ToGroup(*entity.Group) *Group
	ToSkill(*entity.Skill) *Skill
	ToUser(*entity.User) *User
	ToUserField(*entity.UserField) *UserField
	ToWorld(*entity.World) *World
}

type BeforeRenderer interface {
	BeforeRender(context.Context) error
}

type RenderOption struct {
	Name         string
	IsIncludeAll bool
	onlyNames    map[string]struct{}
	exceptNames  map[string]struct{}
	includes     map[string]*RenderOption
}

func (ro *RenderOption) Exists(name string) bool {
	if len(ro.onlyNames) > 0 {
		if _, exists := ro.onlyNames[name]; exists {
			return true
		}
		return false
	}
	if len(ro.exceptNames) > 0 {
		if _, exists := ro.exceptNames[name]; exists {
			return false
		}
		return true
	}
	return true
}

func (ro *RenderOption) IncludeOption(name string) *RenderOption {
	if ro.Name == name {
		return ro
	}
	return ro.includes[name]
}

type RenderOptionBuilder struct {
	onlyNames    map[string]struct{}
	exceptNames  map[string]struct{}
	includes     map[string]*RenderOption
	isIncludeAll bool
}

func NewRenderOptionBuilder() *RenderOptionBuilder {
	return &RenderOptionBuilder{
		exceptNames: map[string]struct{}{},
		includes:    map[string]*RenderOption{},
		onlyNames:   map[string]struct{}{},
	}
}

func (b *RenderOptionBuilder) Only(names ...string) *RenderOptionBuilder {
	for _, name := range names {
		b.onlyNames[name] = struct{}{}
	}
	return b
}

func (b *RenderOptionBuilder) Except(names ...string) *RenderOptionBuilder {
	for _, name := range names {
		b.exceptNames[name] = struct{}{}
	}
	return b
}

func (b *RenderOptionBuilder) Include(name string) *RenderOptionBuilder {
	b.includes[name] = &RenderOption{Name: name}
	return b
}

func (b *RenderOptionBuilder) IncludeWithCallback(name string, callback func(*RenderOptionBuilder)) *RenderOptionBuilder {
	builder := NewRenderOptionBuilder()
	callback(builder)
	opt := builder.Build()
	opt.Name = name
	b.includes[name] = opt
	return b
}

func (b *RenderOptionBuilder) IncludeAll() *RenderOptionBuilder {
	b.isIncludeAll = true
	return b
}

func (b *RenderOptionBuilder) Build() *RenderOption {
	return &RenderOption{
		IsIncludeAll: b.isIncludeAll,
		exceptNames:  b.exceptNames,
		includes:     b.includes,
		onlyNames:    b.onlyNames,
	}
}
