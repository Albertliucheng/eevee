// Code generated by eevee. DO NOT EDIT!

package repository

import (
	"api/dao"
	"api/entity"
	"api/model"
	"context"
	"database/sql"

	"golang.org/x/xerrors"
)

type UserField interface {
	ToModel(*entity.UserField) *model.UserField
	ToModels(entity.UserFields) *model.UserFields
	Create(context.Context, *entity.UserField) (*model.UserField, error)
	Creates(context.Context, entity.UserFields) (*model.UserFields, error)
	FindAll(context.Context) (*model.UserFields, error)
	FindByID(context.Context, uint64) (*model.UserField, error)
	FindByIDs(context.Context, []uint64) (*model.UserFields, error)
	FindByUserID(context.Context, uint64) (*model.UserFields, error)
	FindByUserIDAndFieldID(context.Context, uint64, uint64) (*model.UserField, error)
	FindByUserIDs(context.Context, []uint64) (*model.UserFields, error)
	UpdateByID(context.Context, uint64, map[string]interface{}) error
	UpdateByIDs(context.Context, []uint64, map[string]interface{}) error
	UpdateByUserIDAndFieldID(context.Context, uint64, uint64, map[string]interface{}) error
	DeleteByID(context.Context, uint64) error
	DeleteByIDs(context.Context, []uint64) error
	DeleteByUserIDAndFieldID(context.Context, uint64, uint64) error
	Count(context.Context) (int64, error)
	Delete(context.Context, *entity.UserField) error
	Update(context.Context, *entity.UserField) error
}

type UserFieldImpl struct {
	userFieldDAO dao.UserField
	repo         Repository
	field        Field
}

func NewUserField(ctx context.Context, tx *sql.Tx) *UserFieldImpl {
	return &UserFieldImpl{
		field:        NewField(ctx, tx),
		userFieldDAO: dao.NewUserField(ctx, tx),
	}
}

func (r *UserFieldImpl) ToModel(value *entity.UserField) *model.UserField {
	return r.createCollection(entity.UserFields{value}).First()
}

func (r *UserFieldImpl) ToModels(values entity.UserFields) *model.UserFields {
	return r.createCollection(values)
}

func (r *UserFieldImpl) Create(ctx context.Context, value *entity.UserField) (*model.UserField, error) {
	if err := r.userFieldDAO.Create(ctx, value); err != nil {
		return nil, xerrors.Errorf("cannot Create: %w", err)
	}
	v := r.ToModel(value)
	v.SetSavedValue(value)
	v.SetAlreadyCreated(true)
	return v, nil
}

func (r *UserFieldImpl) Creates(ctx context.Context, entities entity.UserFields) (*model.UserFields, error) {
	for _, v := range entities {
		if _, err := r.Create(ctx, v); err != nil {
			return nil, xerrors.Errorf("cannot Create: %w", err)
		}
	}
	values := r.ToModels(entities)
	values.Each(func(v *model.UserField) {
		v.SetSavedValue(v.UserField)
		v.SetAlreadyCreated(true)
	})
	return values, nil
}

func (r *UserFieldImpl) FindAll(a0 context.Context) (*model.UserFields, error) {
	values, err := r.userFieldDAO.FindAll(a0)
	if err != nil {
		return nil, xerrors.Errorf("failed to FindAll: %w", err)
	}
	collection := r.createCollection(values)
	collection.Each(func(v *model.UserField) {
		v.SetSavedValue(v.UserField)
		v.SetAlreadyCreated(true)
	})
	return collection, nil
}

func (r *UserFieldImpl) FindByID(a0 context.Context, a1 uint64) (*model.UserField, error) {
	value, err := r.userFieldDAO.FindByID(a0, a1)
	if err != nil {
		return nil, xerrors.Errorf("failed to FindByID: %w", err)
	}
	if value == nil {
		return nil, nil
	}
	v := r.createCollection(entity.UserFields{value}).First()
	v.SetSavedValue(v.UserField)
	v.SetAlreadyCreated(true)
	return v, nil
}

func (r *UserFieldImpl) FindByIDs(a0 context.Context, a1 []uint64) (*model.UserFields, error) {
	values, err := r.userFieldDAO.FindByIDs(a0, a1)
	if err != nil {
		return nil, xerrors.Errorf("failed to FindByIDs: %w", err)
	}
	collection := r.createCollection(values)
	collection.Each(func(v *model.UserField) {
		v.SetSavedValue(v.UserField)
		v.SetAlreadyCreated(true)
	})
	return collection, nil
}

func (r *UserFieldImpl) FindByUserID(a0 context.Context, a1 uint64) (*model.UserFields, error) {
	values, err := r.userFieldDAO.FindByUserID(a0, a1)
	if err != nil {
		return nil, xerrors.Errorf("failed to FindByUserID: %w", err)
	}
	collection := r.createCollection(values)
	collection.Each(func(v *model.UserField) {
		v.SetSavedValue(v.UserField)
		v.SetAlreadyCreated(true)
	})
	return collection, nil
}

func (r *UserFieldImpl) FindByUserIDAndFieldID(a0 context.Context, a1 uint64, a2 uint64) (*model.UserField, error) {
	value, err := r.userFieldDAO.FindByUserIDAndFieldID(a0, a1, a2)
	if err != nil {
		return nil, xerrors.Errorf("failed to FindByUserIDAndFieldID: %w", err)
	}
	if value == nil {
		return nil, nil
	}
	v := r.createCollection(entity.UserFields{value}).First()
	v.SetSavedValue(v.UserField)
	v.SetAlreadyCreated(true)
	return v, nil
}

func (r *UserFieldImpl) FindByUserIDs(a0 context.Context, a1 []uint64) (*model.UserFields, error) {
	values, err := r.userFieldDAO.FindByUserIDs(a0, a1)
	if err != nil {
		return nil, xerrors.Errorf("failed to FindByUserIDs: %w", err)
	}
	collection := r.createCollection(values)
	collection.Each(func(v *model.UserField) {
		v.SetSavedValue(v.UserField)
		v.SetAlreadyCreated(true)
	})
	return collection, nil
}

func (r *UserFieldImpl) UpdateByID(a0 context.Context, a1 uint64, a2 map[string]interface{}) error {
	if err := r.userFieldDAO.UpdateByID(a0, a1, a2); err != nil {
		return xerrors.Errorf("failed to update: %w", err)
	}
	return nil
}

func (r *UserFieldImpl) UpdateByIDs(a0 context.Context, a1 []uint64, a2 map[string]interface{}) error {
	if err := r.userFieldDAO.UpdateByIDs(a0, a1, a2); err != nil {
		return xerrors.Errorf("failed to update: %w", err)
	}
	return nil
}

func (r *UserFieldImpl) UpdateByUserIDAndFieldID(a0 context.Context, a1 uint64, a2 uint64, a3 map[string]interface{}) error {
	if err := r.userFieldDAO.UpdateByUserIDAndFieldID(a0, a1, a2, a3); err != nil {
		return xerrors.Errorf("failed to update: %w", err)
	}
	return nil
}

func (r *UserFieldImpl) DeleteByID(a0 context.Context, a1 uint64) error {
	if err := r.userFieldDAO.DeleteByID(a0, a1); err != nil {
		return xerrors.Errorf("failed to delete: %w", err)
	}
	return nil
}

func (r *UserFieldImpl) DeleteByIDs(a0 context.Context, a1 []uint64) error {
	if err := r.userFieldDAO.DeleteByIDs(a0, a1); err != nil {
		return xerrors.Errorf("failed to delete: %w", err)
	}
	return nil
}

func (r *UserFieldImpl) DeleteByUserIDAndFieldID(a0 context.Context, a1 uint64, a2 uint64) error {
	if err := r.userFieldDAO.DeleteByUserIDAndFieldID(a0, a1, a2); err != nil {
		return xerrors.Errorf("failed to delete: %w", err)
	}
	return nil
}

func (r *UserFieldImpl) Count(a0 context.Context) (r0 int64, r1 error) {
	r0, r1 = r.userFieldDAO.Count(a0)
	if r1 != nil {
		r1 = xerrors.Errorf("failed to Count: %w", r1)
	}
	return
}

func (r *UserFieldImpl) Delete(a0 context.Context, a1 *entity.UserField) (r0 error) {
	r0 = r.userFieldDAO.Delete(a0, a1)
	if r0 != nil {
		r0 = xerrors.Errorf("failed to Delete: %w", r0)
	}
	return
}

func (r *UserFieldImpl) Update(a0 context.Context, a1 *entity.UserField) (r0 error) {
	r0 = r.userFieldDAO.Update(a0, a1)
	if r0 != nil {
		r0 = xerrors.Errorf("failed to Update: %w", r0)
	}
	return
}

func (r *UserFieldImpl) createCollection(entities entity.UserFields) *model.UserFields {
	values := model.NewUserFields(entities)
	for i := 0; i < len(entities); i += 1 {
		values.Add(r.create(entities[i], values))
	}
	return values
}

func (r *UserFieldImpl) create(entity *entity.UserField, values *model.UserFields) *model.UserField {
	value := model.NewUserField(entity, r.userFieldDAO)
	r.field.(*FieldImpl).repo = r.repo
	value.Field = func(ctx context.Context) (*model.Field, error) {
		v, err := values.FindField(ctx, value.FieldID, r.field)
		if err != nil {
			return nil, xerrors.Errorf("failed to find field: %w", err)
		}
		return v, nil
	}
	value.SetConverter(r.repo.(model.ModelConverter))
	return value
}
