// Code generated by eevee. DO NOT EDIT!

package repository

import (
	"api/dao"
	"api/entity"
	"api/model"
	"context"
	"database/sql"

	"golang.org/x/xerrors"
)

type User interface {
	ToModel(*entity.User) *model.User
	ToModels(entity.Users) *model.Users
	Create(context.Context, *entity.User) (*model.User, error)
	Creates(context.Context, entity.Users) (*model.Users, error)
	FindAll(context.Context) (*model.Users, error)
	FindByGroupID(context.Context, uint64) (*model.Users, error)
	FindByGroupIDs(context.Context, []uint64) (*model.Users, error)
	FindByID(context.Context, uint64) (*model.User, error)
	FindByIDs(context.Context, []uint64) (*model.Users, error)
	FindByName(context.Context, string) (*model.User, error)
	FindByNames(context.Context, []string) (*model.Users, error)
	FindBySkillID(context.Context, uint64) (*model.Users, error)
	FindBySkillIDAndSkillRank(context.Context, uint64, int) (*model.User, error)
	FindBySkillIDs(context.Context, []uint64) (*model.Users, error)
	FindByWorldID(context.Context, uint64) (*model.Users, error)
	FindByWorldIDAndFieldID(context.Context, uint64, uint64) (*model.Users, error)
	FindByWorldIDs(context.Context, []uint64) (*model.Users, error)
	UpdateByGroupID(context.Context, uint64, map[string]interface{}) error
	UpdateByGroupIDs(context.Context, []uint64, map[string]interface{}) error
	UpdateByID(context.Context, uint64, map[string]interface{}) error
	UpdateByIDs(context.Context, []uint64, map[string]interface{}) error
	UpdateByName(context.Context, string, map[string]interface{}) error
	UpdateByNames(context.Context, []string, map[string]interface{}) error
	UpdateBySkillIDAndSkillRank(context.Context, uint64, int, map[string]interface{}) error
	UpdateByWorldIDAndFieldID(context.Context, uint64, uint64, map[string]interface{}) error
	DeleteByGroupID(context.Context, uint64) error
	DeleteByGroupIDs(context.Context, []uint64) error
	DeleteByID(context.Context, uint64) error
	DeleteByIDs(context.Context, []uint64) error
	DeleteByName(context.Context, string) error
	DeleteByNames(context.Context, []string) error
	DeleteBySkillIDAndSkillRank(context.Context, uint64, int) error
	DeleteByWorldIDAndFieldID(context.Context, uint64, uint64) error
	Count(context.Context) (int64, error)
	Delete(context.Context, *entity.User) error
	Update(context.Context, *entity.User) error
}

type UserImpl struct {
	userDAO   dao.User
	repo      Repository
	skill     Skill
	userField UserField
	world     World
}

func NewUser(ctx context.Context, tx *sql.Tx) *UserImpl {
	return &UserImpl{
		skill:     NewSkill(ctx, tx),
		userDAO:   dao.NewUser(ctx, tx),
		userField: NewUserField(ctx, tx),
		world:     NewWorld(ctx, tx),
	}
}

func (r *UserImpl) ToModel(value *entity.User) *model.User {
	return r.createCollection(entity.Users{value}).First()
}

func (r *UserImpl) ToModels(values entity.Users) *model.Users {
	return r.createCollection(values)
}

func (r *UserImpl) Create(ctx context.Context, value *entity.User) (*model.User, error) {
	if err := r.userDAO.Create(ctx, value); err != nil {
		return nil, xerrors.Errorf("cannot Create: %w", err)
	}
	v := r.ToModel(value)
	v.SetSavedValue(value)
	v.SetAlreadyCreated(true)
	return v, nil
}

func (r *UserImpl) Creates(ctx context.Context, entities entity.Users) (*model.Users, error) {
	for _, v := range entities {
		if _, err := r.Create(ctx, v); err != nil {
			return nil, xerrors.Errorf("cannot Create: %w", err)
		}
	}
	values := r.ToModels(entities)
	values.Each(func(v *model.User) {
		v.SetSavedValue(v.User)
		v.SetAlreadyCreated(true)
	})
	return values, nil
}

func (r *UserImpl) FindAll(a0 context.Context) (*model.Users, error) {
	values, err := r.userDAO.FindAll(a0)
	if err != nil {
		return nil, xerrors.Errorf("failed to FindAll: %w", err)
	}
	collection := r.createCollection(values)
	collection.Each(func(v *model.User) {
		v.SetSavedValue(v.User)
		v.SetAlreadyCreated(true)
	})
	return collection, nil
}

func (r *UserImpl) FindByGroupID(a0 context.Context, a1 uint64) (*model.Users, error) {
	values, err := r.userDAO.FindByGroupID(a0, a1)
	if err != nil {
		return nil, xerrors.Errorf("failed to FindByGroupID: %w", err)
	}
	collection := r.createCollection(values)
	collection.Each(func(v *model.User) {
		v.SetSavedValue(v.User)
		v.SetAlreadyCreated(true)
	})
	return collection, nil
}

func (r *UserImpl) FindByGroupIDs(a0 context.Context, a1 []uint64) (*model.Users, error) {
	values, err := r.userDAO.FindByGroupIDs(a0, a1)
	if err != nil {
		return nil, xerrors.Errorf("failed to FindByGroupIDs: %w", err)
	}
	collection := r.createCollection(values)
	collection.Each(func(v *model.User) {
		v.SetSavedValue(v.User)
		v.SetAlreadyCreated(true)
	})
	return collection, nil
}

func (r *UserImpl) FindByID(a0 context.Context, a1 uint64) (*model.User, error) {
	value, err := r.userDAO.FindByID(a0, a1)
	if err != nil {
		return nil, xerrors.Errorf("failed to FindByID: %w", err)
	}
	if value == nil {
		return nil, nil
	}
	v := r.createCollection(entity.Users{value}).First()
	v.SetSavedValue(v.User)
	v.SetAlreadyCreated(true)
	return v, nil
}

func (r *UserImpl) FindByIDs(a0 context.Context, a1 []uint64) (*model.Users, error) {
	values, err := r.userDAO.FindByIDs(a0, a1)
	if err != nil {
		return nil, xerrors.Errorf("failed to FindByIDs: %w", err)
	}
	collection := r.createCollection(values)
	collection.Each(func(v *model.User) {
		v.SetSavedValue(v.User)
		v.SetAlreadyCreated(true)
	})
	return collection, nil
}

func (r *UserImpl) FindByName(a0 context.Context, a1 string) (*model.User, error) {
	value, err := r.userDAO.FindByName(a0, a1)
	if err != nil {
		return nil, xerrors.Errorf("failed to FindByName: %w", err)
	}
	if value == nil {
		return nil, nil
	}
	v := r.createCollection(entity.Users{value}).First()
	v.SetSavedValue(v.User)
	v.SetAlreadyCreated(true)
	return v, nil
}

func (r *UserImpl) FindByNames(a0 context.Context, a1 []string) (*model.Users, error) {
	values, err := r.userDAO.FindByNames(a0, a1)
	if err != nil {
		return nil, xerrors.Errorf("failed to FindByNames: %w", err)
	}
	collection := r.createCollection(values)
	collection.Each(func(v *model.User) {
		v.SetSavedValue(v.User)
		v.SetAlreadyCreated(true)
	})
	return collection, nil
}

func (r *UserImpl) FindBySkillID(a0 context.Context, a1 uint64) (*model.Users, error) {
	values, err := r.userDAO.FindBySkillID(a0, a1)
	if err != nil {
		return nil, xerrors.Errorf("failed to FindBySkillID: %w", err)
	}
	collection := r.createCollection(values)
	collection.Each(func(v *model.User) {
		v.SetSavedValue(v.User)
		v.SetAlreadyCreated(true)
	})
	return collection, nil
}

func (r *UserImpl) FindBySkillIDAndSkillRank(a0 context.Context, a1 uint64, a2 int) (*model.User, error) {
	value, err := r.userDAO.FindBySkillIDAndSkillRank(a0, a1, a2)
	if err != nil {
		return nil, xerrors.Errorf("failed to FindBySkillIDAndSkillRank: %w", err)
	}
	if value == nil {
		return nil, nil
	}
	v := r.createCollection(entity.Users{value}).First()
	v.SetSavedValue(v.User)
	v.SetAlreadyCreated(true)
	return v, nil
}

func (r *UserImpl) FindBySkillIDs(a0 context.Context, a1 []uint64) (*model.Users, error) {
	values, err := r.userDAO.FindBySkillIDs(a0, a1)
	if err != nil {
		return nil, xerrors.Errorf("failed to FindBySkillIDs: %w", err)
	}
	collection := r.createCollection(values)
	collection.Each(func(v *model.User) {
		v.SetSavedValue(v.User)
		v.SetAlreadyCreated(true)
	})
	return collection, nil
}

func (r *UserImpl) FindByWorldID(a0 context.Context, a1 uint64) (*model.Users, error) {
	values, err := r.userDAO.FindByWorldID(a0, a1)
	if err != nil {
		return nil, xerrors.Errorf("failed to FindByWorldID: %w", err)
	}
	collection := r.createCollection(values)
	collection.Each(func(v *model.User) {
		v.SetSavedValue(v.User)
		v.SetAlreadyCreated(true)
	})
	return collection, nil
}

func (r *UserImpl) FindByWorldIDAndFieldID(a0 context.Context, a1 uint64, a2 uint64) (*model.Users, error) {
	values, err := r.userDAO.FindByWorldIDAndFieldID(a0, a1, a2)
	if err != nil {
		return nil, xerrors.Errorf("failed to FindByWorldIDAndFieldID: %w", err)
	}
	collection := r.createCollection(values)
	collection.Each(func(v *model.User) {
		v.SetSavedValue(v.User)
		v.SetAlreadyCreated(true)
	})
	return collection, nil
}

func (r *UserImpl) FindByWorldIDs(a0 context.Context, a1 []uint64) (*model.Users, error) {
	values, err := r.userDAO.FindByWorldIDs(a0, a1)
	if err != nil {
		return nil, xerrors.Errorf("failed to FindByWorldIDs: %w", err)
	}
	collection := r.createCollection(values)
	collection.Each(func(v *model.User) {
		v.SetSavedValue(v.User)
		v.SetAlreadyCreated(true)
	})
	return collection, nil
}

func (r *UserImpl) UpdateByGroupID(a0 context.Context, a1 uint64, a2 map[string]interface{}) error {
	if err := r.userDAO.UpdateByGroupID(a0, a1, a2); err != nil {
		return xerrors.Errorf("failed to update: %w", err)
	}
	return nil
}

func (r *UserImpl) UpdateByGroupIDs(a0 context.Context, a1 []uint64, a2 map[string]interface{}) error {
	if err := r.userDAO.UpdateByGroupIDs(a0, a1, a2); err != nil {
		return xerrors.Errorf("failed to update: %w", err)
	}
	return nil
}

func (r *UserImpl) UpdateByID(a0 context.Context, a1 uint64, a2 map[string]interface{}) error {
	if err := r.userDAO.UpdateByID(a0, a1, a2); err != nil {
		return xerrors.Errorf("failed to update: %w", err)
	}
	return nil
}

func (r *UserImpl) UpdateByIDs(a0 context.Context, a1 []uint64, a2 map[string]interface{}) error {
	if err := r.userDAO.UpdateByIDs(a0, a1, a2); err != nil {
		return xerrors.Errorf("failed to update: %w", err)
	}
	return nil
}

func (r *UserImpl) UpdateByName(a0 context.Context, a1 string, a2 map[string]interface{}) error {
	if err := r.userDAO.UpdateByName(a0, a1, a2); err != nil {
		return xerrors.Errorf("failed to update: %w", err)
	}
	return nil
}

func (r *UserImpl) UpdateByNames(a0 context.Context, a1 []string, a2 map[string]interface{}) error {
	if err := r.userDAO.UpdateByNames(a0, a1, a2); err != nil {
		return xerrors.Errorf("failed to update: %w", err)
	}
	return nil
}

func (r *UserImpl) UpdateBySkillIDAndSkillRank(a0 context.Context, a1 uint64, a2 int, a3 map[string]interface{}) error {
	if err := r.userDAO.UpdateBySkillIDAndSkillRank(a0, a1, a2, a3); err != nil {
		return xerrors.Errorf("failed to update: %w", err)
	}
	return nil
}

func (r *UserImpl) UpdateByWorldIDAndFieldID(a0 context.Context, a1 uint64, a2 uint64, a3 map[string]interface{}) error {
	if err := r.userDAO.UpdateByWorldIDAndFieldID(a0, a1, a2, a3); err != nil {
		return xerrors.Errorf("failed to update: %w", err)
	}
	return nil
}

func (r *UserImpl) DeleteByGroupID(a0 context.Context, a1 uint64) error {
	if err := r.userDAO.DeleteByGroupID(a0, a1); err != nil {
		return xerrors.Errorf("failed to delete: %w", err)
	}
	return nil
}

func (r *UserImpl) DeleteByGroupIDs(a0 context.Context, a1 []uint64) error {
	if err := r.userDAO.DeleteByGroupIDs(a0, a1); err != nil {
		return xerrors.Errorf("failed to delete: %w", err)
	}
	return nil
}

func (r *UserImpl) DeleteByID(a0 context.Context, a1 uint64) error {
	if err := r.userDAO.DeleteByID(a0, a1); err != nil {
		return xerrors.Errorf("failed to delete: %w", err)
	}
	return nil
}

func (r *UserImpl) DeleteByIDs(a0 context.Context, a1 []uint64) error {
	if err := r.userDAO.DeleteByIDs(a0, a1); err != nil {
		return xerrors.Errorf("failed to delete: %w", err)
	}
	return nil
}

func (r *UserImpl) DeleteByName(a0 context.Context, a1 string) error {
	if err := r.userDAO.DeleteByName(a0, a1); err != nil {
		return xerrors.Errorf("failed to delete: %w", err)
	}
	return nil
}

func (r *UserImpl) DeleteByNames(a0 context.Context, a1 []string) error {
	if err := r.userDAO.DeleteByNames(a0, a1); err != nil {
		return xerrors.Errorf("failed to delete: %w", err)
	}
	return nil
}

func (r *UserImpl) DeleteBySkillIDAndSkillRank(a0 context.Context, a1 uint64, a2 int) error {
	if err := r.userDAO.DeleteBySkillIDAndSkillRank(a0, a1, a2); err != nil {
		return xerrors.Errorf("failed to delete: %w", err)
	}
	return nil
}

func (r *UserImpl) DeleteByWorldIDAndFieldID(a0 context.Context, a1 uint64, a2 uint64) error {
	if err := r.userDAO.DeleteByWorldIDAndFieldID(a0, a1, a2); err != nil {
		return xerrors.Errorf("failed to delete: %w", err)
	}
	return nil
}

func (r *UserImpl) Count(a0 context.Context) (r0 int64, r1 error) {
	r0, r1 = r.userDAO.Count(a0)
	if r1 != nil {
		r1 = xerrors.Errorf("failed to Count: %w", r1)
	}
	return
}

func (r *UserImpl) Delete(a0 context.Context, a1 *entity.User) (r0 error) {
	r0 = r.userDAO.Delete(a0, a1)
	if r0 != nil {
		r0 = xerrors.Errorf("failed to Delete: %w", r0)
	}
	return
}

func (r *UserImpl) Update(a0 context.Context, a1 *entity.User) (r0 error) {
	r0 = r.userDAO.Update(a0, a1)
	if r0 != nil {
		r0 = xerrors.Errorf("failed to Update: %w", r0)
	}
	return
}

func (r *UserImpl) createCollection(entities entity.Users) *model.Users {
	values := model.NewUsers(entities)
	for i := 0; i < len(entities); i += 1 {
		values.Add(r.create(entities[i], values))
	}
	return values
}

func (r *UserImpl) create(entity *entity.User, values *model.Users) *model.User {
	value := model.NewUser(entity, r.userDAO)
	r.userField.(*UserFieldImpl).repo = r.repo
	value.UserFields = func(ctx context.Context) (*model.UserFields, error) {
		v, err := values.FindUserFields(ctx, value.ID, r.userField)
		if err != nil {
			return nil, xerrors.Errorf("failed to find user_fields: %w", err)
		}
		return v, nil
	}
	r.skill.(*SkillImpl).repo = r.repo
	value.Skill = func(ctx context.Context) (*model.Skill, error) {
		v, err := values.FindSkill(ctx, value.SkillID, r.skill)
		if err != nil {
			return nil, xerrors.Errorf("failed to find skill: %w", err)
		}
		return v, nil
	}
	r.world.(*WorldImpl).repo = r.repo
	value.World = func(ctx context.Context) (*model.World, error) {
		v, err := values.FindWorld(ctx, value.WorldID, r.world)
		if err != nil {
			return nil, xerrors.Errorf("failed to find world: %w", err)
		}
		return v, nil
	}
	value.SetConverter(r.repo.(model.ModelConverter))
	return value
}
