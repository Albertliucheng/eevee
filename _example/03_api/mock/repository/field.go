// Code generated by eevee. DO NOT EDIT!

package repository

import (
	"api/entity"
	"api/model"
	"context"
	"log"
	"reflect"

	"golang.org/x/xerrors"
)

type FieldMock struct {
	expect *FieldExpect
}

func (r *FieldMock) EXPECT() *FieldExpect {
	return r.expect
}

func NewFieldMock() *FieldMock {
	return &FieldMock{expect: NewFieldExpect()}
}

type FieldToModelExpect struct {
	expect        *FieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(value *entity.Field)
	value         *entity.Field
	r0            *model.Field
}

func (r *FieldToModelExpect) Return(r0 *model.Field) *FieldToModelExpect {
	r.r0 = r0
	return r
}

func (r *FieldToModelExpect) Do(action func(value *entity.Field)) *FieldToModelExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *FieldToModelExpect) OutOfOrder() *FieldToModelExpect {
	r.isOutOfOrder = true
	return r
}

func (r *FieldToModelExpect) AnyTimes() *FieldToModelExpect {
	r.isAnyTimes = true
	return r
}

func (r *FieldToModelExpect) Times(n int) *FieldToModelExpect {
	r.requiredTimes = n
	return r
}

func (r *FieldMock) ToModel(value *entity.Field) (r0 *model.Field) {
	if len(r.expect.toModel) == 0 {
		log.Printf("cannot find mock method for Field.ToModel")
		return
	}
	for _, exp := range r.expect.toModel {
		if !reflect.DeepEqual(exp.value, value) {
			continue
		}
		for _, action := range exp.actions {
			action(value)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			log.Printf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	log.Printf("invalid argument Field value:[%+v]", value)
	return
}

func (r *FieldExpect) ToModel(value *entity.Field) *FieldToModelExpect {
	exp := &FieldToModelExpect{
		actions: []func(value *entity.Field){},
		expect:  r,
		value:   value,
	}
	r.toModel = append(r.toModel, exp)
	return exp
}

type FieldToModelsExpect struct {
	expect        *FieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(values entity.Fields)
	values        entity.Fields
	r0            *model.Fields
}

func (r *FieldToModelsExpect) Return(r0 *model.Fields) *FieldToModelsExpect {
	r.r0 = r0
	return r
}

func (r *FieldToModelsExpect) Do(action func(values entity.Fields)) *FieldToModelsExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *FieldToModelsExpect) OutOfOrder() *FieldToModelsExpect {
	r.isOutOfOrder = true
	return r
}

func (r *FieldToModelsExpect) AnyTimes() *FieldToModelsExpect {
	r.isAnyTimes = true
	return r
}

func (r *FieldToModelsExpect) Times(n int) *FieldToModelsExpect {
	r.requiredTimes = n
	return r
}

func (r *FieldMock) ToModels(values entity.Fields) (r0 *model.Fields) {
	if len(r.expect.toModels) == 0 {
		log.Printf("cannot find mock method for Field.ToModels")
		return
	}
	for _, exp := range r.expect.toModels {
		if !reflect.DeepEqual(exp.values, values) {
			continue
		}
		for _, action := range exp.actions {
			action(values)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			log.Printf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	log.Printf("invalid argument Field values:[%+v]", values)
	return
}

func (r *FieldExpect) ToModels(values entity.Fields) *FieldToModelsExpect {
	exp := &FieldToModelsExpect{
		actions: []func(values entity.Fields){},
		expect:  r,
		values:  values,
	}
	r.toModels = append(r.toModels, exp)
	return exp
}

type FieldCreateExpect struct {
	expect        *FieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(ctx context.Context, value *entity.Field)
	ctx           context.Context
	value         *entity.Field
	r0            *model.Field
	r1            error
}

func (r *FieldCreateExpect) Return(r0 *model.Field, r1 error) *FieldCreateExpect {
	r.r0 = r0
	r.r1 = r1
	return r
}

func (r *FieldCreateExpect) Do(action func(ctx context.Context, value *entity.Field)) *FieldCreateExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *FieldCreateExpect) OutOfOrder() *FieldCreateExpect {
	r.isOutOfOrder = true
	return r
}

func (r *FieldCreateExpect) AnyTimes() *FieldCreateExpect {
	r.isAnyTimes = true
	return r
}

func (r *FieldCreateExpect) Times(n int) *FieldCreateExpect {
	r.requiredTimes = n
	return r
}

func (r *FieldMock) Create(ctx context.Context, value *entity.Field) (r0 *model.Field, r1 error) {
	if len(r.expect.create) == 0 {
		r1 = xerrors.New("cannot find mock method for Field.Create")
		return
	}
	for _, exp := range r.expect.create {
		if !reflect.DeepEqual(exp.ctx, ctx) {
			continue
		}
		if !reflect.DeepEqual(exp.value, value) {
			continue
		}
		for _, action := range exp.actions {
			action(ctx, value)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			r1 = exp.r1
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r1 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		r1 = exp.r1
		return
	}
	r1 = xerrors.Errorf("invalid argument Field ctx:[%+v] value:[%+v]", ctx, value)
	return
}

func (r *FieldExpect) Create(ctx context.Context, value *entity.Field) *FieldCreateExpect {
	exp := &FieldCreateExpect{
		actions: []func(ctx context.Context, value *entity.Field){},
		ctx:     ctx,
		expect:  r,
		value:   value,
	}
	r.create = append(r.create, exp)
	return exp
}

type FieldCreatesExpect struct {
	expect        *FieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(ctx context.Context, entities entity.Fields)
	ctx           context.Context
	entities      entity.Fields
	r0            *model.Fields
	r1            error
}

func (r *FieldCreatesExpect) Return(r0 *model.Fields, r1 error) *FieldCreatesExpect {
	r.r0 = r0
	r.r1 = r1
	return r
}

func (r *FieldCreatesExpect) Do(action func(ctx context.Context, entities entity.Fields)) *FieldCreatesExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *FieldCreatesExpect) OutOfOrder() *FieldCreatesExpect {
	r.isOutOfOrder = true
	return r
}

func (r *FieldCreatesExpect) AnyTimes() *FieldCreatesExpect {
	r.isAnyTimes = true
	return r
}

func (r *FieldCreatesExpect) Times(n int) *FieldCreatesExpect {
	r.requiredTimes = n
	return r
}

func (r *FieldMock) Creates(ctx context.Context, entities entity.Fields) (r0 *model.Fields, r1 error) {
	if len(r.expect.creates) == 0 {
		r1 = xerrors.New("cannot find mock method for Field.Creates")
		return
	}
	for _, exp := range r.expect.creates {
		if !reflect.DeepEqual(exp.ctx, ctx) {
			continue
		}
		if !reflect.DeepEqual(exp.entities, entities) {
			continue
		}
		for _, action := range exp.actions {
			action(ctx, entities)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			r1 = exp.r1
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r1 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		r1 = exp.r1
		return
	}
	r1 = xerrors.Errorf("invalid argument Field ctx:[%+v] entities:[%+v]", ctx, entities)
	return
}

func (r *FieldExpect) Creates(ctx context.Context, entities entity.Fields) *FieldCreatesExpect {
	exp := &FieldCreatesExpect{
		actions:  []func(ctx context.Context, entities entity.Fields){},
		ctx:      ctx,
		entities: entities,
		expect:   r,
	}
	r.creates = append(r.creates, exp)
	return exp
}

type FieldFindAllExpect struct {
	expect        *FieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context)
	a0            context.Context
	r0            *model.Fields
	r1            error
}

func (r *FieldFindAllExpect) Return(r0 *model.Fields, r1 error) *FieldFindAllExpect {
	r.r0 = r0
	r.r1 = r1
	return r
}

func (r *FieldFindAllExpect) Do(action func(a0 context.Context)) *FieldFindAllExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *FieldFindAllExpect) OutOfOrder() *FieldFindAllExpect {
	r.isOutOfOrder = true
	return r
}

func (r *FieldFindAllExpect) AnyTimes() *FieldFindAllExpect {
	r.isAnyTimes = true
	return r
}

func (r *FieldFindAllExpect) Times(n int) *FieldFindAllExpect {
	r.requiredTimes = n
	return r
}

func (r *FieldMock) FindAll(a0 context.Context) (r0 *model.Fields, r1 error) {
	if len(r.expect.findAll) == 0 {
		r1 = xerrors.New("cannot find mock method for Field.FindAll")
		return
	}
	for _, exp := range r.expect.findAll {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		for _, action := range exp.actions {
			action(a0)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			r1 = exp.r1
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r1 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		r1 = exp.r1
		return
	}
	r1 = xerrors.Errorf("invalid argument Field a0:[%+v]", a0)
	return
}

func (r *FieldExpect) FindAll(a0 context.Context) *FieldFindAllExpect {
	exp := &FieldFindAllExpect{
		a0:      a0,
		actions: []func(a0 context.Context){},
		expect:  r,
	}
	r.findAll = append(r.findAll, exp)
	return exp
}

type FieldFindByDifficultiesExpect struct {
	expect        *FieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 []int)
	a0            context.Context
	a1            []int
	r0            *model.Fields
	r1            error
}

func (r *FieldFindByDifficultiesExpect) Return(r0 *model.Fields, r1 error) *FieldFindByDifficultiesExpect {
	r.r0 = r0
	r.r1 = r1
	return r
}

func (r *FieldFindByDifficultiesExpect) Do(action func(a0 context.Context, a1 []int)) *FieldFindByDifficultiesExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *FieldFindByDifficultiesExpect) OutOfOrder() *FieldFindByDifficultiesExpect {
	r.isOutOfOrder = true
	return r
}

func (r *FieldFindByDifficultiesExpect) AnyTimes() *FieldFindByDifficultiesExpect {
	r.isAnyTimes = true
	return r
}

func (r *FieldFindByDifficultiesExpect) Times(n int) *FieldFindByDifficultiesExpect {
	r.requiredTimes = n
	return r
}

func (r *FieldMock) FindByDifficulties(a0 context.Context, a1 []int) (r0 *model.Fields, r1 error) {
	if len(r.expect.findByDifficulties) == 0 {
		r1 = xerrors.New("cannot find mock method for Field.FindByDifficulties")
		return
	}
	for _, exp := range r.expect.findByDifficulties {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if len(exp.a1) != len(a1) {
			continue
		}
		if exp.isOutOfOrder {
			isMatched := func() bool {
				for _, exp := range exp.a1 {
					found := false
					for idx, act := range a1 {
						if exp != act {
							continue
						}
						a1 = append(a1[:idx], a1[idx+1:]...)
						found = true
						break
					}
					if !found {
						return false
					}
				}
				return true
			}()
			if !isMatched {
				continue
			}
		} else {
			if !reflect.DeepEqual(exp.a1, a1) {
				continue
			}
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			r1 = exp.r1
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r1 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		r1 = exp.r1
		return
	}
	r1 = xerrors.Errorf("invalid argument Field a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *FieldExpect) FindByDifficulties(a0 context.Context, a1 []int) *FieldFindByDifficultiesExpect {
	exp := &FieldFindByDifficultiesExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 []int){},
		expect:  r,
	}
	r.findByDifficulties = append(r.findByDifficulties, exp)
	return exp
}

type FieldFindByDifficultyExpect struct {
	expect        *FieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 int)
	a0            context.Context
	a1            int
	r0            *model.Fields
	r1            error
}

func (r *FieldFindByDifficultyExpect) Return(r0 *model.Fields, r1 error) *FieldFindByDifficultyExpect {
	r.r0 = r0
	r.r1 = r1
	return r
}

func (r *FieldFindByDifficultyExpect) Do(action func(a0 context.Context, a1 int)) *FieldFindByDifficultyExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *FieldFindByDifficultyExpect) OutOfOrder() *FieldFindByDifficultyExpect {
	r.isOutOfOrder = true
	return r
}

func (r *FieldFindByDifficultyExpect) AnyTimes() *FieldFindByDifficultyExpect {
	r.isAnyTimes = true
	return r
}

func (r *FieldFindByDifficultyExpect) Times(n int) *FieldFindByDifficultyExpect {
	r.requiredTimes = n
	return r
}

func (r *FieldMock) FindByDifficulty(a0 context.Context, a1 int) (r0 *model.Fields, r1 error) {
	if len(r.expect.findByDifficulty) == 0 {
		r1 = xerrors.New("cannot find mock method for Field.FindByDifficulty")
		return
	}
	for _, exp := range r.expect.findByDifficulty {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			r1 = exp.r1
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r1 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		r1 = exp.r1
		return
	}
	r1 = xerrors.Errorf("invalid argument Field a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *FieldExpect) FindByDifficulty(a0 context.Context, a1 int) *FieldFindByDifficultyExpect {
	exp := &FieldFindByDifficultyExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 int){},
		expect:  r,
	}
	r.findByDifficulty = append(r.findByDifficulty, exp)
	return exp
}

type FieldFindByDifficultyAndLevelExpect struct {
	expect        *FieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 int, a2 int)
	a0            context.Context
	a1            int
	a2            int
	r0            *model.Fields
	r1            error
}

func (r *FieldFindByDifficultyAndLevelExpect) Return(r0 *model.Fields, r1 error) *FieldFindByDifficultyAndLevelExpect {
	r.r0 = r0
	r.r1 = r1
	return r
}

func (r *FieldFindByDifficultyAndLevelExpect) Do(action func(a0 context.Context, a1 int, a2 int)) *FieldFindByDifficultyAndLevelExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *FieldFindByDifficultyAndLevelExpect) OutOfOrder() *FieldFindByDifficultyAndLevelExpect {
	r.isOutOfOrder = true
	return r
}

func (r *FieldFindByDifficultyAndLevelExpect) AnyTimes() *FieldFindByDifficultyAndLevelExpect {
	r.isAnyTimes = true
	return r
}

func (r *FieldFindByDifficultyAndLevelExpect) Times(n int) *FieldFindByDifficultyAndLevelExpect {
	r.requiredTimes = n
	return r
}

func (r *FieldMock) FindByDifficultyAndLevel(a0 context.Context, a1 int, a2 int) (r0 *model.Fields, r1 error) {
	if len(r.expect.findByDifficultyAndLevel) == 0 {
		r1 = xerrors.New("cannot find mock method for Field.FindByDifficultyAndLevel")
		return
	}
	for _, exp := range r.expect.findByDifficultyAndLevel {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		if !reflect.DeepEqual(exp.a2, a2) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1, a2)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			r1 = exp.r1
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r1 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		r1 = exp.r1
		return
	}
	r1 = xerrors.Errorf("invalid argument Field a0:[%+v] a1:[%+v] a2:[%+v]", a0, a1, a2)
	return
}

func (r *FieldExpect) FindByDifficultyAndLevel(a0 context.Context, a1 int, a2 int) *FieldFindByDifficultyAndLevelExpect {
	exp := &FieldFindByDifficultyAndLevelExpect{
		a0:      a0,
		a1:      a1,
		a2:      a2,
		actions: []func(a0 context.Context, a1 int, a2 int){},
		expect:  r,
	}
	r.findByDifficultyAndLevel = append(r.findByDifficultyAndLevel, exp)
	return exp
}

type FieldFindByIDExpect struct {
	expect        *FieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 uint64)
	a0            context.Context
	a1            uint64
	r0            *model.Field
	r1            error
}

func (r *FieldFindByIDExpect) Return(r0 *model.Field, r1 error) *FieldFindByIDExpect {
	r.r0 = r0
	r.r1 = r1
	return r
}

func (r *FieldFindByIDExpect) Do(action func(a0 context.Context, a1 uint64)) *FieldFindByIDExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *FieldFindByIDExpect) OutOfOrder() *FieldFindByIDExpect {
	r.isOutOfOrder = true
	return r
}

func (r *FieldFindByIDExpect) AnyTimes() *FieldFindByIDExpect {
	r.isAnyTimes = true
	return r
}

func (r *FieldFindByIDExpect) Times(n int) *FieldFindByIDExpect {
	r.requiredTimes = n
	return r
}

func (r *FieldMock) FindByID(a0 context.Context, a1 uint64) (r0 *model.Field, r1 error) {
	if len(r.expect.findByID) == 0 {
		r1 = xerrors.New("cannot find mock method for Field.FindByID")
		return
	}
	for _, exp := range r.expect.findByID {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			r1 = exp.r1
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r1 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		r1 = exp.r1
		return
	}
	r1 = xerrors.Errorf("invalid argument Field a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *FieldExpect) FindByID(a0 context.Context, a1 uint64) *FieldFindByIDExpect {
	exp := &FieldFindByIDExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 uint64){},
		expect:  r,
	}
	r.findByID = append(r.findByID, exp)
	return exp
}

type FieldFindByIDsExpect struct {
	expect        *FieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 []uint64)
	a0            context.Context
	a1            []uint64
	r0            *model.Fields
	r1            error
}

func (r *FieldFindByIDsExpect) Return(r0 *model.Fields, r1 error) *FieldFindByIDsExpect {
	r.r0 = r0
	r.r1 = r1
	return r
}

func (r *FieldFindByIDsExpect) Do(action func(a0 context.Context, a1 []uint64)) *FieldFindByIDsExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *FieldFindByIDsExpect) OutOfOrder() *FieldFindByIDsExpect {
	r.isOutOfOrder = true
	return r
}

func (r *FieldFindByIDsExpect) AnyTimes() *FieldFindByIDsExpect {
	r.isAnyTimes = true
	return r
}

func (r *FieldFindByIDsExpect) Times(n int) *FieldFindByIDsExpect {
	r.requiredTimes = n
	return r
}

func (r *FieldMock) FindByIDs(a0 context.Context, a1 []uint64) (r0 *model.Fields, r1 error) {
	if len(r.expect.findByIDs) == 0 {
		r1 = xerrors.New("cannot find mock method for Field.FindByIDs")
		return
	}
	for _, exp := range r.expect.findByIDs {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if len(exp.a1) != len(a1) {
			continue
		}
		if exp.isOutOfOrder {
			isMatched := func() bool {
				for _, exp := range exp.a1 {
					found := false
					for idx, act := range a1 {
						if exp != act {
							continue
						}
						a1 = append(a1[:idx], a1[idx+1:]...)
						found = true
						break
					}
					if !found {
						return false
					}
				}
				return true
			}()
			if !isMatched {
				continue
			}
		} else {
			if !reflect.DeepEqual(exp.a1, a1) {
				continue
			}
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			r1 = exp.r1
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r1 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		r1 = exp.r1
		return
	}
	r1 = xerrors.Errorf("invalid argument Field a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *FieldExpect) FindByIDs(a0 context.Context, a1 []uint64) *FieldFindByIDsExpect {
	exp := &FieldFindByIDsExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 []uint64){},
		expect:  r,
	}
	r.findByIDs = append(r.findByIDs, exp)
	return exp
}

type FieldFindByLocationXExpect struct {
	expect        *FieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 int)
	a0            context.Context
	a1            int
	r0            *model.Fields
	r1            error
}

func (r *FieldFindByLocationXExpect) Return(r0 *model.Fields, r1 error) *FieldFindByLocationXExpect {
	r.r0 = r0
	r.r1 = r1
	return r
}

func (r *FieldFindByLocationXExpect) Do(action func(a0 context.Context, a1 int)) *FieldFindByLocationXExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *FieldFindByLocationXExpect) OutOfOrder() *FieldFindByLocationXExpect {
	r.isOutOfOrder = true
	return r
}

func (r *FieldFindByLocationXExpect) AnyTimes() *FieldFindByLocationXExpect {
	r.isAnyTimes = true
	return r
}

func (r *FieldFindByLocationXExpect) Times(n int) *FieldFindByLocationXExpect {
	r.requiredTimes = n
	return r
}

func (r *FieldMock) FindByLocationX(a0 context.Context, a1 int) (r0 *model.Fields, r1 error) {
	if len(r.expect.findByLocationX) == 0 {
		r1 = xerrors.New("cannot find mock method for Field.FindByLocationX")
		return
	}
	for _, exp := range r.expect.findByLocationX {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			r1 = exp.r1
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r1 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		r1 = exp.r1
		return
	}
	r1 = xerrors.Errorf("invalid argument Field a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *FieldExpect) FindByLocationX(a0 context.Context, a1 int) *FieldFindByLocationXExpect {
	exp := &FieldFindByLocationXExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 int){},
		expect:  r,
	}
	r.findByLocationX = append(r.findByLocationX, exp)
	return exp
}

type FieldFindByLocationXAndLocationYExpect struct {
	expect        *FieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 int, a2 int)
	a0            context.Context
	a1            int
	a2            int
	r0            *model.Field
	r1            error
}

func (r *FieldFindByLocationXAndLocationYExpect) Return(r0 *model.Field, r1 error) *FieldFindByLocationXAndLocationYExpect {
	r.r0 = r0
	r.r1 = r1
	return r
}

func (r *FieldFindByLocationXAndLocationYExpect) Do(action func(a0 context.Context, a1 int, a2 int)) *FieldFindByLocationXAndLocationYExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *FieldFindByLocationXAndLocationYExpect) OutOfOrder() *FieldFindByLocationXAndLocationYExpect {
	r.isOutOfOrder = true
	return r
}

func (r *FieldFindByLocationXAndLocationYExpect) AnyTimes() *FieldFindByLocationXAndLocationYExpect {
	r.isAnyTimes = true
	return r
}

func (r *FieldFindByLocationXAndLocationYExpect) Times(n int) *FieldFindByLocationXAndLocationYExpect {
	r.requiredTimes = n
	return r
}

func (r *FieldMock) FindByLocationXAndLocationY(a0 context.Context, a1 int, a2 int) (r0 *model.Field, r1 error) {
	if len(r.expect.findByLocationXAndLocationY) == 0 {
		r1 = xerrors.New("cannot find mock method for Field.FindByLocationXAndLocationY")
		return
	}
	for _, exp := range r.expect.findByLocationXAndLocationY {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		if !reflect.DeepEqual(exp.a2, a2) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1, a2)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			r1 = exp.r1
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r1 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		r1 = exp.r1
		return
	}
	r1 = xerrors.Errorf("invalid argument Field a0:[%+v] a1:[%+v] a2:[%+v]", a0, a1, a2)
	return
}

func (r *FieldExpect) FindByLocationXAndLocationY(a0 context.Context, a1 int, a2 int) *FieldFindByLocationXAndLocationYExpect {
	exp := &FieldFindByLocationXAndLocationYExpect{
		a0:      a0,
		a1:      a1,
		a2:      a2,
		actions: []func(a0 context.Context, a1 int, a2 int){},
		expect:  r,
	}
	r.findByLocationXAndLocationY = append(r.findByLocationXAndLocationY, exp)
	return exp
}

type FieldFindByLocationXesExpect struct {
	expect        *FieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 []int)
	a0            context.Context
	a1            []int
	r0            *model.Fields
	r1            error
}

func (r *FieldFindByLocationXesExpect) Return(r0 *model.Fields, r1 error) *FieldFindByLocationXesExpect {
	r.r0 = r0
	r.r1 = r1
	return r
}

func (r *FieldFindByLocationXesExpect) Do(action func(a0 context.Context, a1 []int)) *FieldFindByLocationXesExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *FieldFindByLocationXesExpect) OutOfOrder() *FieldFindByLocationXesExpect {
	r.isOutOfOrder = true
	return r
}

func (r *FieldFindByLocationXesExpect) AnyTimes() *FieldFindByLocationXesExpect {
	r.isAnyTimes = true
	return r
}

func (r *FieldFindByLocationXesExpect) Times(n int) *FieldFindByLocationXesExpect {
	r.requiredTimes = n
	return r
}

func (r *FieldMock) FindByLocationXes(a0 context.Context, a1 []int) (r0 *model.Fields, r1 error) {
	if len(r.expect.findByLocationXes) == 0 {
		r1 = xerrors.New("cannot find mock method for Field.FindByLocationXes")
		return
	}
	for _, exp := range r.expect.findByLocationXes {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if len(exp.a1) != len(a1) {
			continue
		}
		if exp.isOutOfOrder {
			isMatched := func() bool {
				for _, exp := range exp.a1 {
					found := false
					for idx, act := range a1 {
						if exp != act {
							continue
						}
						a1 = append(a1[:idx], a1[idx+1:]...)
						found = true
						break
					}
					if !found {
						return false
					}
				}
				return true
			}()
			if !isMatched {
				continue
			}
		} else {
			if !reflect.DeepEqual(exp.a1, a1) {
				continue
			}
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			r1 = exp.r1
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r1 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		r1 = exp.r1
		return
	}
	r1 = xerrors.Errorf("invalid argument Field a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *FieldExpect) FindByLocationXes(a0 context.Context, a1 []int) *FieldFindByLocationXesExpect {
	exp := &FieldFindByLocationXesExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 []int){},
		expect:  r,
	}
	r.findByLocationXes = append(r.findByLocationXes, exp)
	return exp
}

type FieldFindByNameExpect struct {
	expect        *FieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 string)
	a0            context.Context
	a1            string
	r0            *model.Field
	r1            error
}

func (r *FieldFindByNameExpect) Return(r0 *model.Field, r1 error) *FieldFindByNameExpect {
	r.r0 = r0
	r.r1 = r1
	return r
}

func (r *FieldFindByNameExpect) Do(action func(a0 context.Context, a1 string)) *FieldFindByNameExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *FieldFindByNameExpect) OutOfOrder() *FieldFindByNameExpect {
	r.isOutOfOrder = true
	return r
}

func (r *FieldFindByNameExpect) AnyTimes() *FieldFindByNameExpect {
	r.isAnyTimes = true
	return r
}

func (r *FieldFindByNameExpect) Times(n int) *FieldFindByNameExpect {
	r.requiredTimes = n
	return r
}

func (r *FieldMock) FindByName(a0 context.Context, a1 string) (r0 *model.Field, r1 error) {
	if len(r.expect.findByName) == 0 {
		r1 = xerrors.New("cannot find mock method for Field.FindByName")
		return
	}
	for _, exp := range r.expect.findByName {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			r1 = exp.r1
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r1 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		r1 = exp.r1
		return
	}
	r1 = xerrors.Errorf("invalid argument Field a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *FieldExpect) FindByName(a0 context.Context, a1 string) *FieldFindByNameExpect {
	exp := &FieldFindByNameExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 string){},
		expect:  r,
	}
	r.findByName = append(r.findByName, exp)
	return exp
}

type FieldFindByNamesExpect struct {
	expect        *FieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 []string)
	a0            context.Context
	a1            []string
	r0            *model.Fields
	r1            error
}

func (r *FieldFindByNamesExpect) Return(r0 *model.Fields, r1 error) *FieldFindByNamesExpect {
	r.r0 = r0
	r.r1 = r1
	return r
}

func (r *FieldFindByNamesExpect) Do(action func(a0 context.Context, a1 []string)) *FieldFindByNamesExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *FieldFindByNamesExpect) OutOfOrder() *FieldFindByNamesExpect {
	r.isOutOfOrder = true
	return r
}

func (r *FieldFindByNamesExpect) AnyTimes() *FieldFindByNamesExpect {
	r.isAnyTimes = true
	return r
}

func (r *FieldFindByNamesExpect) Times(n int) *FieldFindByNamesExpect {
	r.requiredTimes = n
	return r
}

func (r *FieldMock) FindByNames(a0 context.Context, a1 []string) (r0 *model.Fields, r1 error) {
	if len(r.expect.findByNames) == 0 {
		r1 = xerrors.New("cannot find mock method for Field.FindByNames")
		return
	}
	for _, exp := range r.expect.findByNames {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if len(exp.a1) != len(a1) {
			continue
		}
		if exp.isOutOfOrder {
			isMatched := func() bool {
				for _, exp := range exp.a1 {
					found := false
					for idx, act := range a1 {
						if exp != act {
							continue
						}
						a1 = append(a1[:idx], a1[idx+1:]...)
						found = true
						break
					}
					if !found {
						return false
					}
				}
				return true
			}()
			if !isMatched {
				continue
			}
		} else {
			if !reflect.DeepEqual(exp.a1, a1) {
				continue
			}
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			r1 = exp.r1
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r1 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		r1 = exp.r1
		return
	}
	r1 = xerrors.Errorf("invalid argument Field a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *FieldExpect) FindByNames(a0 context.Context, a1 []string) *FieldFindByNamesExpect {
	exp := &FieldFindByNamesExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 []string){},
		expect:  r,
	}
	r.findByNames = append(r.findByNames, exp)
	return exp
}

type FieldFindByObjectNumExpect struct {
	expect        *FieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 int)
	a0            context.Context
	a1            int
	r0            *model.Fields
	r1            error
}

func (r *FieldFindByObjectNumExpect) Return(r0 *model.Fields, r1 error) *FieldFindByObjectNumExpect {
	r.r0 = r0
	r.r1 = r1
	return r
}

func (r *FieldFindByObjectNumExpect) Do(action func(a0 context.Context, a1 int)) *FieldFindByObjectNumExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *FieldFindByObjectNumExpect) OutOfOrder() *FieldFindByObjectNumExpect {
	r.isOutOfOrder = true
	return r
}

func (r *FieldFindByObjectNumExpect) AnyTimes() *FieldFindByObjectNumExpect {
	r.isAnyTimes = true
	return r
}

func (r *FieldFindByObjectNumExpect) Times(n int) *FieldFindByObjectNumExpect {
	r.requiredTimes = n
	return r
}

func (r *FieldMock) FindByObjectNum(a0 context.Context, a1 int) (r0 *model.Fields, r1 error) {
	if len(r.expect.findByObjectNum) == 0 {
		r1 = xerrors.New("cannot find mock method for Field.FindByObjectNum")
		return
	}
	for _, exp := range r.expect.findByObjectNum {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			r1 = exp.r1
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r1 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		r1 = exp.r1
		return
	}
	r1 = xerrors.Errorf("invalid argument Field a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *FieldExpect) FindByObjectNum(a0 context.Context, a1 int) *FieldFindByObjectNumExpect {
	exp := &FieldFindByObjectNumExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 int){},
		expect:  r,
	}
	r.findByObjectNum = append(r.findByObjectNum, exp)
	return exp
}

type FieldFindByObjectNumsExpect struct {
	expect        *FieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 []int)
	a0            context.Context
	a1            []int
	r0            *model.Fields
	r1            error
}

func (r *FieldFindByObjectNumsExpect) Return(r0 *model.Fields, r1 error) *FieldFindByObjectNumsExpect {
	r.r0 = r0
	r.r1 = r1
	return r
}

func (r *FieldFindByObjectNumsExpect) Do(action func(a0 context.Context, a1 []int)) *FieldFindByObjectNumsExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *FieldFindByObjectNumsExpect) OutOfOrder() *FieldFindByObjectNumsExpect {
	r.isOutOfOrder = true
	return r
}

func (r *FieldFindByObjectNumsExpect) AnyTimes() *FieldFindByObjectNumsExpect {
	r.isAnyTimes = true
	return r
}

func (r *FieldFindByObjectNumsExpect) Times(n int) *FieldFindByObjectNumsExpect {
	r.requiredTimes = n
	return r
}

func (r *FieldMock) FindByObjectNums(a0 context.Context, a1 []int) (r0 *model.Fields, r1 error) {
	if len(r.expect.findByObjectNums) == 0 {
		r1 = xerrors.New("cannot find mock method for Field.FindByObjectNums")
		return
	}
	for _, exp := range r.expect.findByObjectNums {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if len(exp.a1) != len(a1) {
			continue
		}
		if exp.isOutOfOrder {
			isMatched := func() bool {
				for _, exp := range exp.a1 {
					found := false
					for idx, act := range a1 {
						if exp != act {
							continue
						}
						a1 = append(a1[:idx], a1[idx+1:]...)
						found = true
						break
					}
					if !found {
						return false
					}
				}
				return true
			}()
			if !isMatched {
				continue
			}
		} else {
			if !reflect.DeepEqual(exp.a1, a1) {
				continue
			}
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			r1 = exp.r1
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r1 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		r1 = exp.r1
		return
	}
	r1 = xerrors.Errorf("invalid argument Field a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *FieldExpect) FindByObjectNums(a0 context.Context, a1 []int) *FieldFindByObjectNumsExpect {
	exp := &FieldFindByObjectNumsExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 []int){},
		expect:  r,
	}
	r.findByObjectNums = append(r.findByObjectNums, exp)
	return exp
}

type FieldUpdateByDifficultyAndLevelExpect struct {
	expect        *FieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 int, a2 int, a3 map[string]interface{})
	a0            context.Context
	a1            int
	a2            int
	a3            map[string]interface{}
	r0            error
}

func (r *FieldUpdateByDifficultyAndLevelExpect) Return(r0 error) *FieldUpdateByDifficultyAndLevelExpect {
	r.r0 = r0
	return r
}

func (r *FieldUpdateByDifficultyAndLevelExpect) Do(action func(a0 context.Context, a1 int, a2 int, a3 map[string]interface{})) *FieldUpdateByDifficultyAndLevelExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *FieldUpdateByDifficultyAndLevelExpect) OutOfOrder() *FieldUpdateByDifficultyAndLevelExpect {
	r.isOutOfOrder = true
	return r
}

func (r *FieldUpdateByDifficultyAndLevelExpect) AnyTimes() *FieldUpdateByDifficultyAndLevelExpect {
	r.isAnyTimes = true
	return r
}

func (r *FieldUpdateByDifficultyAndLevelExpect) Times(n int) *FieldUpdateByDifficultyAndLevelExpect {
	r.requiredTimes = n
	return r
}

func (r *FieldMock) UpdateByDifficultyAndLevel(a0 context.Context, a1 int, a2 int, a3 map[string]interface{}) (r0 error) {
	if len(r.expect.updateByDifficultyAndLevel) == 0 {
		r0 = xerrors.New("cannot find mock method for Field.UpdateByDifficultyAndLevel")
		return
	}
	for _, exp := range r.expect.updateByDifficultyAndLevel {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		if !reflect.DeepEqual(exp.a2, a2) {
			continue
		}
		if !reflect.DeepEqual(exp.a3, a3) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1, a2, a3)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument Field a0:[%+v] a1:[%+v] a2:[%+v] a3:[%+v]", a0, a1, a2, a3)
	return
}

func (r *FieldExpect) UpdateByDifficultyAndLevel(a0 context.Context, a1 int, a2 int, a3 map[string]interface{}) *FieldUpdateByDifficultyAndLevelExpect {
	exp := &FieldUpdateByDifficultyAndLevelExpect{
		a0:      a0,
		a1:      a1,
		a2:      a2,
		a3:      a3,
		actions: []func(a0 context.Context, a1 int, a2 int, a3 map[string]interface{}){},
		expect:  r,
	}
	r.updateByDifficultyAndLevel = append(r.updateByDifficultyAndLevel, exp)
	return exp
}

type FieldUpdateByIDExpect struct {
	expect        *FieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 uint64, a2 map[string]interface{})
	a0            context.Context
	a1            uint64
	a2            map[string]interface{}
	r0            error
}

func (r *FieldUpdateByIDExpect) Return(r0 error) *FieldUpdateByIDExpect {
	r.r0 = r0
	return r
}

func (r *FieldUpdateByIDExpect) Do(action func(a0 context.Context, a1 uint64, a2 map[string]interface{})) *FieldUpdateByIDExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *FieldUpdateByIDExpect) OutOfOrder() *FieldUpdateByIDExpect {
	r.isOutOfOrder = true
	return r
}

func (r *FieldUpdateByIDExpect) AnyTimes() *FieldUpdateByIDExpect {
	r.isAnyTimes = true
	return r
}

func (r *FieldUpdateByIDExpect) Times(n int) *FieldUpdateByIDExpect {
	r.requiredTimes = n
	return r
}

func (r *FieldMock) UpdateByID(a0 context.Context, a1 uint64, a2 map[string]interface{}) (r0 error) {
	if len(r.expect.updateByID) == 0 {
		r0 = xerrors.New("cannot find mock method for Field.UpdateByID")
		return
	}
	for _, exp := range r.expect.updateByID {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		if !reflect.DeepEqual(exp.a2, a2) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1, a2)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument Field a0:[%+v] a1:[%+v] a2:[%+v]", a0, a1, a2)
	return
}

func (r *FieldExpect) UpdateByID(a0 context.Context, a1 uint64, a2 map[string]interface{}) *FieldUpdateByIDExpect {
	exp := &FieldUpdateByIDExpect{
		a0:      a0,
		a1:      a1,
		a2:      a2,
		actions: []func(a0 context.Context, a1 uint64, a2 map[string]interface{}){},
		expect:  r,
	}
	r.updateByID = append(r.updateByID, exp)
	return exp
}

type FieldUpdateByIDsExpect struct {
	expect        *FieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 []uint64, a2 map[string]interface{})
	a0            context.Context
	a1            []uint64
	a2            map[string]interface{}
	r0            error
}

func (r *FieldUpdateByIDsExpect) Return(r0 error) *FieldUpdateByIDsExpect {
	r.r0 = r0
	return r
}

func (r *FieldUpdateByIDsExpect) Do(action func(a0 context.Context, a1 []uint64, a2 map[string]interface{})) *FieldUpdateByIDsExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *FieldUpdateByIDsExpect) OutOfOrder() *FieldUpdateByIDsExpect {
	r.isOutOfOrder = true
	return r
}

func (r *FieldUpdateByIDsExpect) AnyTimes() *FieldUpdateByIDsExpect {
	r.isAnyTimes = true
	return r
}

func (r *FieldUpdateByIDsExpect) Times(n int) *FieldUpdateByIDsExpect {
	r.requiredTimes = n
	return r
}

func (r *FieldMock) UpdateByIDs(a0 context.Context, a1 []uint64, a2 map[string]interface{}) (r0 error) {
	if len(r.expect.updateByIDs) == 0 {
		r0 = xerrors.New("cannot find mock method for Field.UpdateByIDs")
		return
	}
	for _, exp := range r.expect.updateByIDs {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if len(exp.a1) != len(a1) {
			continue
		}
		if exp.isOutOfOrder {
			isMatched := func() bool {
				for _, exp := range exp.a1 {
					found := false
					for idx, act := range a1 {
						if exp != act {
							continue
						}
						a1 = append(a1[:idx], a1[idx+1:]...)
						found = true
						break
					}
					if !found {
						return false
					}
				}
				return true
			}()
			if !isMatched {
				continue
			}
		} else {
			if !reflect.DeepEqual(exp.a1, a1) {
				continue
			}
		}
		if !reflect.DeepEqual(exp.a2, a2) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1, a2)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument Field a0:[%+v] a1:[%+v] a2:[%+v]", a0, a1, a2)
	return
}

func (r *FieldExpect) UpdateByIDs(a0 context.Context, a1 []uint64, a2 map[string]interface{}) *FieldUpdateByIDsExpect {
	exp := &FieldUpdateByIDsExpect{
		a0:      a0,
		a1:      a1,
		a2:      a2,
		actions: []func(a0 context.Context, a1 []uint64, a2 map[string]interface{}){},
		expect:  r,
	}
	r.updateByIDs = append(r.updateByIDs, exp)
	return exp
}

type FieldUpdateByLocationXAndLocationYExpect struct {
	expect        *FieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 int, a2 int, a3 map[string]interface{})
	a0            context.Context
	a1            int
	a2            int
	a3            map[string]interface{}
	r0            error
}

func (r *FieldUpdateByLocationXAndLocationYExpect) Return(r0 error) *FieldUpdateByLocationXAndLocationYExpect {
	r.r0 = r0
	return r
}

func (r *FieldUpdateByLocationXAndLocationYExpect) Do(action func(a0 context.Context, a1 int, a2 int, a3 map[string]interface{})) *FieldUpdateByLocationXAndLocationYExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *FieldUpdateByLocationXAndLocationYExpect) OutOfOrder() *FieldUpdateByLocationXAndLocationYExpect {
	r.isOutOfOrder = true
	return r
}

func (r *FieldUpdateByLocationXAndLocationYExpect) AnyTimes() *FieldUpdateByLocationXAndLocationYExpect {
	r.isAnyTimes = true
	return r
}

func (r *FieldUpdateByLocationXAndLocationYExpect) Times(n int) *FieldUpdateByLocationXAndLocationYExpect {
	r.requiredTimes = n
	return r
}

func (r *FieldMock) UpdateByLocationXAndLocationY(a0 context.Context, a1 int, a2 int, a3 map[string]interface{}) (r0 error) {
	if len(r.expect.updateByLocationXAndLocationY) == 0 {
		r0 = xerrors.New("cannot find mock method for Field.UpdateByLocationXAndLocationY")
		return
	}
	for _, exp := range r.expect.updateByLocationXAndLocationY {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		if !reflect.DeepEqual(exp.a2, a2) {
			continue
		}
		if !reflect.DeepEqual(exp.a3, a3) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1, a2, a3)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument Field a0:[%+v] a1:[%+v] a2:[%+v] a3:[%+v]", a0, a1, a2, a3)
	return
}

func (r *FieldExpect) UpdateByLocationXAndLocationY(a0 context.Context, a1 int, a2 int, a3 map[string]interface{}) *FieldUpdateByLocationXAndLocationYExpect {
	exp := &FieldUpdateByLocationXAndLocationYExpect{
		a0:      a0,
		a1:      a1,
		a2:      a2,
		a3:      a3,
		actions: []func(a0 context.Context, a1 int, a2 int, a3 map[string]interface{}){},
		expect:  r,
	}
	r.updateByLocationXAndLocationY = append(r.updateByLocationXAndLocationY, exp)
	return exp
}

type FieldUpdateByNameExpect struct {
	expect        *FieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 string, a2 map[string]interface{})
	a0            context.Context
	a1            string
	a2            map[string]interface{}
	r0            error
}

func (r *FieldUpdateByNameExpect) Return(r0 error) *FieldUpdateByNameExpect {
	r.r0 = r0
	return r
}

func (r *FieldUpdateByNameExpect) Do(action func(a0 context.Context, a1 string, a2 map[string]interface{})) *FieldUpdateByNameExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *FieldUpdateByNameExpect) OutOfOrder() *FieldUpdateByNameExpect {
	r.isOutOfOrder = true
	return r
}

func (r *FieldUpdateByNameExpect) AnyTimes() *FieldUpdateByNameExpect {
	r.isAnyTimes = true
	return r
}

func (r *FieldUpdateByNameExpect) Times(n int) *FieldUpdateByNameExpect {
	r.requiredTimes = n
	return r
}

func (r *FieldMock) UpdateByName(a0 context.Context, a1 string, a2 map[string]interface{}) (r0 error) {
	if len(r.expect.updateByName) == 0 {
		r0 = xerrors.New("cannot find mock method for Field.UpdateByName")
		return
	}
	for _, exp := range r.expect.updateByName {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		if !reflect.DeepEqual(exp.a2, a2) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1, a2)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument Field a0:[%+v] a1:[%+v] a2:[%+v]", a0, a1, a2)
	return
}

func (r *FieldExpect) UpdateByName(a0 context.Context, a1 string, a2 map[string]interface{}) *FieldUpdateByNameExpect {
	exp := &FieldUpdateByNameExpect{
		a0:      a0,
		a1:      a1,
		a2:      a2,
		actions: []func(a0 context.Context, a1 string, a2 map[string]interface{}){},
		expect:  r,
	}
	r.updateByName = append(r.updateByName, exp)
	return exp
}

type FieldUpdateByNamesExpect struct {
	expect        *FieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 []string, a2 map[string]interface{})
	a0            context.Context
	a1            []string
	a2            map[string]interface{}
	r0            error
}

func (r *FieldUpdateByNamesExpect) Return(r0 error) *FieldUpdateByNamesExpect {
	r.r0 = r0
	return r
}

func (r *FieldUpdateByNamesExpect) Do(action func(a0 context.Context, a1 []string, a2 map[string]interface{})) *FieldUpdateByNamesExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *FieldUpdateByNamesExpect) OutOfOrder() *FieldUpdateByNamesExpect {
	r.isOutOfOrder = true
	return r
}

func (r *FieldUpdateByNamesExpect) AnyTimes() *FieldUpdateByNamesExpect {
	r.isAnyTimes = true
	return r
}

func (r *FieldUpdateByNamesExpect) Times(n int) *FieldUpdateByNamesExpect {
	r.requiredTimes = n
	return r
}

func (r *FieldMock) UpdateByNames(a0 context.Context, a1 []string, a2 map[string]interface{}) (r0 error) {
	if len(r.expect.updateByNames) == 0 {
		r0 = xerrors.New("cannot find mock method for Field.UpdateByNames")
		return
	}
	for _, exp := range r.expect.updateByNames {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if len(exp.a1) != len(a1) {
			continue
		}
		if exp.isOutOfOrder {
			isMatched := func() bool {
				for _, exp := range exp.a1 {
					found := false
					for idx, act := range a1 {
						if exp != act {
							continue
						}
						a1 = append(a1[:idx], a1[idx+1:]...)
						found = true
						break
					}
					if !found {
						return false
					}
				}
				return true
			}()
			if !isMatched {
				continue
			}
		} else {
			if !reflect.DeepEqual(exp.a1, a1) {
				continue
			}
		}
		if !reflect.DeepEqual(exp.a2, a2) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1, a2)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument Field a0:[%+v] a1:[%+v] a2:[%+v]", a0, a1, a2)
	return
}

func (r *FieldExpect) UpdateByNames(a0 context.Context, a1 []string, a2 map[string]interface{}) *FieldUpdateByNamesExpect {
	exp := &FieldUpdateByNamesExpect{
		a0:      a0,
		a1:      a1,
		a2:      a2,
		actions: []func(a0 context.Context, a1 []string, a2 map[string]interface{}){},
		expect:  r,
	}
	r.updateByNames = append(r.updateByNames, exp)
	return exp
}

type FieldUpdateByObjectNumExpect struct {
	expect        *FieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 int, a2 map[string]interface{})
	a0            context.Context
	a1            int
	a2            map[string]interface{}
	r0            error
}

func (r *FieldUpdateByObjectNumExpect) Return(r0 error) *FieldUpdateByObjectNumExpect {
	r.r0 = r0
	return r
}

func (r *FieldUpdateByObjectNumExpect) Do(action func(a0 context.Context, a1 int, a2 map[string]interface{})) *FieldUpdateByObjectNumExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *FieldUpdateByObjectNumExpect) OutOfOrder() *FieldUpdateByObjectNumExpect {
	r.isOutOfOrder = true
	return r
}

func (r *FieldUpdateByObjectNumExpect) AnyTimes() *FieldUpdateByObjectNumExpect {
	r.isAnyTimes = true
	return r
}

func (r *FieldUpdateByObjectNumExpect) Times(n int) *FieldUpdateByObjectNumExpect {
	r.requiredTimes = n
	return r
}

func (r *FieldMock) UpdateByObjectNum(a0 context.Context, a1 int, a2 map[string]interface{}) (r0 error) {
	if len(r.expect.updateByObjectNum) == 0 {
		r0 = xerrors.New("cannot find mock method for Field.UpdateByObjectNum")
		return
	}
	for _, exp := range r.expect.updateByObjectNum {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		if !reflect.DeepEqual(exp.a2, a2) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1, a2)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument Field a0:[%+v] a1:[%+v] a2:[%+v]", a0, a1, a2)
	return
}

func (r *FieldExpect) UpdateByObjectNum(a0 context.Context, a1 int, a2 map[string]interface{}) *FieldUpdateByObjectNumExpect {
	exp := &FieldUpdateByObjectNumExpect{
		a0:      a0,
		a1:      a1,
		a2:      a2,
		actions: []func(a0 context.Context, a1 int, a2 map[string]interface{}){},
		expect:  r,
	}
	r.updateByObjectNum = append(r.updateByObjectNum, exp)
	return exp
}

type FieldUpdateByObjectNumsExpect struct {
	expect        *FieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 []int, a2 map[string]interface{})
	a0            context.Context
	a1            []int
	a2            map[string]interface{}
	r0            error
}

func (r *FieldUpdateByObjectNumsExpect) Return(r0 error) *FieldUpdateByObjectNumsExpect {
	r.r0 = r0
	return r
}

func (r *FieldUpdateByObjectNumsExpect) Do(action func(a0 context.Context, a1 []int, a2 map[string]interface{})) *FieldUpdateByObjectNumsExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *FieldUpdateByObjectNumsExpect) OutOfOrder() *FieldUpdateByObjectNumsExpect {
	r.isOutOfOrder = true
	return r
}

func (r *FieldUpdateByObjectNumsExpect) AnyTimes() *FieldUpdateByObjectNumsExpect {
	r.isAnyTimes = true
	return r
}

func (r *FieldUpdateByObjectNumsExpect) Times(n int) *FieldUpdateByObjectNumsExpect {
	r.requiredTimes = n
	return r
}

func (r *FieldMock) UpdateByObjectNums(a0 context.Context, a1 []int, a2 map[string]interface{}) (r0 error) {
	if len(r.expect.updateByObjectNums) == 0 {
		r0 = xerrors.New("cannot find mock method for Field.UpdateByObjectNums")
		return
	}
	for _, exp := range r.expect.updateByObjectNums {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if len(exp.a1) != len(a1) {
			continue
		}
		if exp.isOutOfOrder {
			isMatched := func() bool {
				for _, exp := range exp.a1 {
					found := false
					for idx, act := range a1 {
						if exp != act {
							continue
						}
						a1 = append(a1[:idx], a1[idx+1:]...)
						found = true
						break
					}
					if !found {
						return false
					}
				}
				return true
			}()
			if !isMatched {
				continue
			}
		} else {
			if !reflect.DeepEqual(exp.a1, a1) {
				continue
			}
		}
		if !reflect.DeepEqual(exp.a2, a2) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1, a2)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument Field a0:[%+v] a1:[%+v] a2:[%+v]", a0, a1, a2)
	return
}

func (r *FieldExpect) UpdateByObjectNums(a0 context.Context, a1 []int, a2 map[string]interface{}) *FieldUpdateByObjectNumsExpect {
	exp := &FieldUpdateByObjectNumsExpect{
		a0:      a0,
		a1:      a1,
		a2:      a2,
		actions: []func(a0 context.Context, a1 []int, a2 map[string]interface{}){},
		expect:  r,
	}
	r.updateByObjectNums = append(r.updateByObjectNums, exp)
	return exp
}

type FieldDeleteByDifficultyAndLevelExpect struct {
	expect        *FieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 int, a2 int)
	a0            context.Context
	a1            int
	a2            int
	r0            error
}

func (r *FieldDeleteByDifficultyAndLevelExpect) Return(r0 error) *FieldDeleteByDifficultyAndLevelExpect {
	r.r0 = r0
	return r
}

func (r *FieldDeleteByDifficultyAndLevelExpect) Do(action func(a0 context.Context, a1 int, a2 int)) *FieldDeleteByDifficultyAndLevelExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *FieldDeleteByDifficultyAndLevelExpect) OutOfOrder() *FieldDeleteByDifficultyAndLevelExpect {
	r.isOutOfOrder = true
	return r
}

func (r *FieldDeleteByDifficultyAndLevelExpect) AnyTimes() *FieldDeleteByDifficultyAndLevelExpect {
	r.isAnyTimes = true
	return r
}

func (r *FieldDeleteByDifficultyAndLevelExpect) Times(n int) *FieldDeleteByDifficultyAndLevelExpect {
	r.requiredTimes = n
	return r
}

func (r *FieldMock) DeleteByDifficultyAndLevel(a0 context.Context, a1 int, a2 int) (r0 error) {
	if len(r.expect.deleteByDifficultyAndLevel) == 0 {
		r0 = xerrors.New("cannot find mock method for Field.DeleteByDifficultyAndLevel")
		return
	}
	for _, exp := range r.expect.deleteByDifficultyAndLevel {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		if !reflect.DeepEqual(exp.a2, a2) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1, a2)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument Field a0:[%+v] a1:[%+v] a2:[%+v]", a0, a1, a2)
	return
}

func (r *FieldExpect) DeleteByDifficultyAndLevel(a0 context.Context, a1 int, a2 int) *FieldDeleteByDifficultyAndLevelExpect {
	exp := &FieldDeleteByDifficultyAndLevelExpect{
		a0:      a0,
		a1:      a1,
		a2:      a2,
		actions: []func(a0 context.Context, a1 int, a2 int){},
		expect:  r,
	}
	r.deleteByDifficultyAndLevel = append(r.deleteByDifficultyAndLevel, exp)
	return exp
}

type FieldDeleteByIDExpect struct {
	expect        *FieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 uint64)
	a0            context.Context
	a1            uint64
	r0            error
}

func (r *FieldDeleteByIDExpect) Return(r0 error) *FieldDeleteByIDExpect {
	r.r0 = r0
	return r
}

func (r *FieldDeleteByIDExpect) Do(action func(a0 context.Context, a1 uint64)) *FieldDeleteByIDExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *FieldDeleteByIDExpect) OutOfOrder() *FieldDeleteByIDExpect {
	r.isOutOfOrder = true
	return r
}

func (r *FieldDeleteByIDExpect) AnyTimes() *FieldDeleteByIDExpect {
	r.isAnyTimes = true
	return r
}

func (r *FieldDeleteByIDExpect) Times(n int) *FieldDeleteByIDExpect {
	r.requiredTimes = n
	return r
}

func (r *FieldMock) DeleteByID(a0 context.Context, a1 uint64) (r0 error) {
	if len(r.expect.deleteByID) == 0 {
		r0 = xerrors.New("cannot find mock method for Field.DeleteByID")
		return
	}
	for _, exp := range r.expect.deleteByID {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument Field a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *FieldExpect) DeleteByID(a0 context.Context, a1 uint64) *FieldDeleteByIDExpect {
	exp := &FieldDeleteByIDExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 uint64){},
		expect:  r,
	}
	r.deleteByID = append(r.deleteByID, exp)
	return exp
}

type FieldDeleteByIDsExpect struct {
	expect        *FieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 []uint64)
	a0            context.Context
	a1            []uint64
	r0            error
}

func (r *FieldDeleteByIDsExpect) Return(r0 error) *FieldDeleteByIDsExpect {
	r.r0 = r0
	return r
}

func (r *FieldDeleteByIDsExpect) Do(action func(a0 context.Context, a1 []uint64)) *FieldDeleteByIDsExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *FieldDeleteByIDsExpect) OutOfOrder() *FieldDeleteByIDsExpect {
	r.isOutOfOrder = true
	return r
}

func (r *FieldDeleteByIDsExpect) AnyTimes() *FieldDeleteByIDsExpect {
	r.isAnyTimes = true
	return r
}

func (r *FieldDeleteByIDsExpect) Times(n int) *FieldDeleteByIDsExpect {
	r.requiredTimes = n
	return r
}

func (r *FieldMock) DeleteByIDs(a0 context.Context, a1 []uint64) (r0 error) {
	if len(r.expect.deleteByIDs) == 0 {
		r0 = xerrors.New("cannot find mock method for Field.DeleteByIDs")
		return
	}
	for _, exp := range r.expect.deleteByIDs {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if len(exp.a1) != len(a1) {
			continue
		}
		if exp.isOutOfOrder {
			isMatched := func() bool {
				for _, exp := range exp.a1 {
					found := false
					for idx, act := range a1 {
						if exp != act {
							continue
						}
						a1 = append(a1[:idx], a1[idx+1:]...)
						found = true
						break
					}
					if !found {
						return false
					}
				}
				return true
			}()
			if !isMatched {
				continue
			}
		} else {
			if !reflect.DeepEqual(exp.a1, a1) {
				continue
			}
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument Field a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *FieldExpect) DeleteByIDs(a0 context.Context, a1 []uint64) *FieldDeleteByIDsExpect {
	exp := &FieldDeleteByIDsExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 []uint64){},
		expect:  r,
	}
	r.deleteByIDs = append(r.deleteByIDs, exp)
	return exp
}

type FieldDeleteByLocationXAndLocationYExpect struct {
	expect        *FieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 int, a2 int)
	a0            context.Context
	a1            int
	a2            int
	r0            error
}

func (r *FieldDeleteByLocationXAndLocationYExpect) Return(r0 error) *FieldDeleteByLocationXAndLocationYExpect {
	r.r0 = r0
	return r
}

func (r *FieldDeleteByLocationXAndLocationYExpect) Do(action func(a0 context.Context, a1 int, a2 int)) *FieldDeleteByLocationXAndLocationYExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *FieldDeleteByLocationXAndLocationYExpect) OutOfOrder() *FieldDeleteByLocationXAndLocationYExpect {
	r.isOutOfOrder = true
	return r
}

func (r *FieldDeleteByLocationXAndLocationYExpect) AnyTimes() *FieldDeleteByLocationXAndLocationYExpect {
	r.isAnyTimes = true
	return r
}

func (r *FieldDeleteByLocationXAndLocationYExpect) Times(n int) *FieldDeleteByLocationXAndLocationYExpect {
	r.requiredTimes = n
	return r
}

func (r *FieldMock) DeleteByLocationXAndLocationY(a0 context.Context, a1 int, a2 int) (r0 error) {
	if len(r.expect.deleteByLocationXAndLocationY) == 0 {
		r0 = xerrors.New("cannot find mock method for Field.DeleteByLocationXAndLocationY")
		return
	}
	for _, exp := range r.expect.deleteByLocationXAndLocationY {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		if !reflect.DeepEqual(exp.a2, a2) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1, a2)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument Field a0:[%+v] a1:[%+v] a2:[%+v]", a0, a1, a2)
	return
}

func (r *FieldExpect) DeleteByLocationXAndLocationY(a0 context.Context, a1 int, a2 int) *FieldDeleteByLocationXAndLocationYExpect {
	exp := &FieldDeleteByLocationXAndLocationYExpect{
		a0:      a0,
		a1:      a1,
		a2:      a2,
		actions: []func(a0 context.Context, a1 int, a2 int){},
		expect:  r,
	}
	r.deleteByLocationXAndLocationY = append(r.deleteByLocationXAndLocationY, exp)
	return exp
}

type FieldDeleteByNameExpect struct {
	expect        *FieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 string)
	a0            context.Context
	a1            string
	r0            error
}

func (r *FieldDeleteByNameExpect) Return(r0 error) *FieldDeleteByNameExpect {
	r.r0 = r0
	return r
}

func (r *FieldDeleteByNameExpect) Do(action func(a0 context.Context, a1 string)) *FieldDeleteByNameExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *FieldDeleteByNameExpect) OutOfOrder() *FieldDeleteByNameExpect {
	r.isOutOfOrder = true
	return r
}

func (r *FieldDeleteByNameExpect) AnyTimes() *FieldDeleteByNameExpect {
	r.isAnyTimes = true
	return r
}

func (r *FieldDeleteByNameExpect) Times(n int) *FieldDeleteByNameExpect {
	r.requiredTimes = n
	return r
}

func (r *FieldMock) DeleteByName(a0 context.Context, a1 string) (r0 error) {
	if len(r.expect.deleteByName) == 0 {
		r0 = xerrors.New("cannot find mock method for Field.DeleteByName")
		return
	}
	for _, exp := range r.expect.deleteByName {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument Field a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *FieldExpect) DeleteByName(a0 context.Context, a1 string) *FieldDeleteByNameExpect {
	exp := &FieldDeleteByNameExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 string){},
		expect:  r,
	}
	r.deleteByName = append(r.deleteByName, exp)
	return exp
}

type FieldDeleteByNamesExpect struct {
	expect        *FieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 []string)
	a0            context.Context
	a1            []string
	r0            error
}

func (r *FieldDeleteByNamesExpect) Return(r0 error) *FieldDeleteByNamesExpect {
	r.r0 = r0
	return r
}

func (r *FieldDeleteByNamesExpect) Do(action func(a0 context.Context, a1 []string)) *FieldDeleteByNamesExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *FieldDeleteByNamesExpect) OutOfOrder() *FieldDeleteByNamesExpect {
	r.isOutOfOrder = true
	return r
}

func (r *FieldDeleteByNamesExpect) AnyTimes() *FieldDeleteByNamesExpect {
	r.isAnyTimes = true
	return r
}

func (r *FieldDeleteByNamesExpect) Times(n int) *FieldDeleteByNamesExpect {
	r.requiredTimes = n
	return r
}

func (r *FieldMock) DeleteByNames(a0 context.Context, a1 []string) (r0 error) {
	if len(r.expect.deleteByNames) == 0 {
		r0 = xerrors.New("cannot find mock method for Field.DeleteByNames")
		return
	}
	for _, exp := range r.expect.deleteByNames {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if len(exp.a1) != len(a1) {
			continue
		}
		if exp.isOutOfOrder {
			isMatched := func() bool {
				for _, exp := range exp.a1 {
					found := false
					for idx, act := range a1 {
						if exp != act {
							continue
						}
						a1 = append(a1[:idx], a1[idx+1:]...)
						found = true
						break
					}
					if !found {
						return false
					}
				}
				return true
			}()
			if !isMatched {
				continue
			}
		} else {
			if !reflect.DeepEqual(exp.a1, a1) {
				continue
			}
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument Field a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *FieldExpect) DeleteByNames(a0 context.Context, a1 []string) *FieldDeleteByNamesExpect {
	exp := &FieldDeleteByNamesExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 []string){},
		expect:  r,
	}
	r.deleteByNames = append(r.deleteByNames, exp)
	return exp
}

type FieldDeleteByObjectNumExpect struct {
	expect        *FieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 int)
	a0            context.Context
	a1            int
	r0            error
}

func (r *FieldDeleteByObjectNumExpect) Return(r0 error) *FieldDeleteByObjectNumExpect {
	r.r0 = r0
	return r
}

func (r *FieldDeleteByObjectNumExpect) Do(action func(a0 context.Context, a1 int)) *FieldDeleteByObjectNumExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *FieldDeleteByObjectNumExpect) OutOfOrder() *FieldDeleteByObjectNumExpect {
	r.isOutOfOrder = true
	return r
}

func (r *FieldDeleteByObjectNumExpect) AnyTimes() *FieldDeleteByObjectNumExpect {
	r.isAnyTimes = true
	return r
}

func (r *FieldDeleteByObjectNumExpect) Times(n int) *FieldDeleteByObjectNumExpect {
	r.requiredTimes = n
	return r
}

func (r *FieldMock) DeleteByObjectNum(a0 context.Context, a1 int) (r0 error) {
	if len(r.expect.deleteByObjectNum) == 0 {
		r0 = xerrors.New("cannot find mock method for Field.DeleteByObjectNum")
		return
	}
	for _, exp := range r.expect.deleteByObjectNum {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument Field a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *FieldExpect) DeleteByObjectNum(a0 context.Context, a1 int) *FieldDeleteByObjectNumExpect {
	exp := &FieldDeleteByObjectNumExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 int){},
		expect:  r,
	}
	r.deleteByObjectNum = append(r.deleteByObjectNum, exp)
	return exp
}

type FieldDeleteByObjectNumsExpect struct {
	expect        *FieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 []int)
	a0            context.Context
	a1            []int
	r0            error
}

func (r *FieldDeleteByObjectNumsExpect) Return(r0 error) *FieldDeleteByObjectNumsExpect {
	r.r0 = r0
	return r
}

func (r *FieldDeleteByObjectNumsExpect) Do(action func(a0 context.Context, a1 []int)) *FieldDeleteByObjectNumsExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *FieldDeleteByObjectNumsExpect) OutOfOrder() *FieldDeleteByObjectNumsExpect {
	r.isOutOfOrder = true
	return r
}

func (r *FieldDeleteByObjectNumsExpect) AnyTimes() *FieldDeleteByObjectNumsExpect {
	r.isAnyTimes = true
	return r
}

func (r *FieldDeleteByObjectNumsExpect) Times(n int) *FieldDeleteByObjectNumsExpect {
	r.requiredTimes = n
	return r
}

func (r *FieldMock) DeleteByObjectNums(a0 context.Context, a1 []int) (r0 error) {
	if len(r.expect.deleteByObjectNums) == 0 {
		r0 = xerrors.New("cannot find mock method for Field.DeleteByObjectNums")
		return
	}
	for _, exp := range r.expect.deleteByObjectNums {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if len(exp.a1) != len(a1) {
			continue
		}
		if exp.isOutOfOrder {
			isMatched := func() bool {
				for _, exp := range exp.a1 {
					found := false
					for idx, act := range a1 {
						if exp != act {
							continue
						}
						a1 = append(a1[:idx], a1[idx+1:]...)
						found = true
						break
					}
					if !found {
						return false
					}
				}
				return true
			}()
			if !isMatched {
				continue
			}
		} else {
			if !reflect.DeepEqual(exp.a1, a1) {
				continue
			}
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument Field a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *FieldExpect) DeleteByObjectNums(a0 context.Context, a1 []int) *FieldDeleteByObjectNumsExpect {
	exp := &FieldDeleteByObjectNumsExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 []int){},
		expect:  r,
	}
	r.deleteByObjectNums = append(r.deleteByObjectNums, exp)
	return exp
}

type FieldCountExpect struct {
	expect        *FieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context)
	a0            context.Context
	r0            int64
	r1            error
}

func (r *FieldCountExpect) Return(r0 int64, r1 error) *FieldCountExpect {
	r.r0 = r0
	r.r1 = r1
	return r
}

func (r *FieldCountExpect) Do(action func(a0 context.Context)) *FieldCountExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *FieldCountExpect) OutOfOrder() *FieldCountExpect {
	r.isOutOfOrder = true
	return r
}

func (r *FieldCountExpect) AnyTimes() *FieldCountExpect {
	r.isAnyTimes = true
	return r
}

func (r *FieldCountExpect) Times(n int) *FieldCountExpect {
	r.requiredTimes = n
	return r
}

func (r *FieldMock) Count(a0 context.Context) (r0 int64, r1 error) {
	if len(r.expect.count) == 0 {
		r1 = xerrors.New("cannot find mock method for Field.Count")
		return
	}
	for _, exp := range r.expect.count {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		for _, action := range exp.actions {
			action(a0)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			r1 = exp.r1
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r1 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		r1 = exp.r1
		return
	}
	r1 = xerrors.Errorf("invalid argument Field a0:[%+v]", a0)
	return
}

func (r *FieldExpect) Count(a0 context.Context) *FieldCountExpect {
	exp := &FieldCountExpect{
		a0:      a0,
		actions: []func(a0 context.Context){},
		expect:  r,
	}
	r.count = append(r.count, exp)
	return exp
}

type FieldDeleteExpect struct {
	expect        *FieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 *entity.Field)
	a0            context.Context
	a1            *entity.Field
	r0            error
}

func (r *FieldDeleteExpect) Return(r0 error) *FieldDeleteExpect {
	r.r0 = r0
	return r
}

func (r *FieldDeleteExpect) Do(action func(a0 context.Context, a1 *entity.Field)) *FieldDeleteExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *FieldDeleteExpect) OutOfOrder() *FieldDeleteExpect {
	r.isOutOfOrder = true
	return r
}

func (r *FieldDeleteExpect) AnyTimes() *FieldDeleteExpect {
	r.isAnyTimes = true
	return r
}

func (r *FieldDeleteExpect) Times(n int) *FieldDeleteExpect {
	r.requiredTimes = n
	return r
}

func (r *FieldMock) Delete(a0 context.Context, a1 *entity.Field) (r0 error) {
	if len(r.expect.delete) == 0 {
		r0 = xerrors.New("cannot find mock method for Field.Delete")
		return
	}
	for _, exp := range r.expect.delete {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument Field a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *FieldExpect) Delete(a0 context.Context, a1 *entity.Field) *FieldDeleteExpect {
	exp := &FieldDeleteExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 *entity.Field){},
		expect:  r,
	}
	r.delete = append(r.delete, exp)
	return exp
}

type FieldUpdateExpect struct {
	expect        *FieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 *entity.Field)
	a0            context.Context
	a1            *entity.Field
	r0            error
}

func (r *FieldUpdateExpect) Return(r0 error) *FieldUpdateExpect {
	r.r0 = r0
	return r
}

func (r *FieldUpdateExpect) Do(action func(a0 context.Context, a1 *entity.Field)) *FieldUpdateExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *FieldUpdateExpect) OutOfOrder() *FieldUpdateExpect {
	r.isOutOfOrder = true
	return r
}

func (r *FieldUpdateExpect) AnyTimes() *FieldUpdateExpect {
	r.isAnyTimes = true
	return r
}

func (r *FieldUpdateExpect) Times(n int) *FieldUpdateExpect {
	r.requiredTimes = n
	return r
}

func (r *FieldMock) Update(a0 context.Context, a1 *entity.Field) (r0 error) {
	if len(r.expect.update) == 0 {
		r0 = xerrors.New("cannot find mock method for Field.Update")
		return
	}
	for _, exp := range r.expect.update {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument Field a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *FieldExpect) Update(a0 context.Context, a1 *entity.Field) *FieldUpdateExpect {
	exp := &FieldUpdateExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 *entity.Field){},
		expect:  r,
	}
	r.update = append(r.update, exp)
	return exp
}

type FieldExpect struct {
	toModel                       []*FieldToModelExpect
	toModels                      []*FieldToModelsExpect
	create                        []*FieldCreateExpect
	creates                       []*FieldCreatesExpect
	findAll                       []*FieldFindAllExpect
	findByDifficulties            []*FieldFindByDifficultiesExpect
	findByDifficulty              []*FieldFindByDifficultyExpect
	findByDifficultyAndLevel      []*FieldFindByDifficultyAndLevelExpect
	findByID                      []*FieldFindByIDExpect
	findByIDs                     []*FieldFindByIDsExpect
	findByLocationX               []*FieldFindByLocationXExpect
	findByLocationXAndLocationY   []*FieldFindByLocationXAndLocationYExpect
	findByLocationXes             []*FieldFindByLocationXesExpect
	findByName                    []*FieldFindByNameExpect
	findByNames                   []*FieldFindByNamesExpect
	findByObjectNum               []*FieldFindByObjectNumExpect
	findByObjectNums              []*FieldFindByObjectNumsExpect
	updateByDifficultyAndLevel    []*FieldUpdateByDifficultyAndLevelExpect
	updateByID                    []*FieldUpdateByIDExpect
	updateByIDs                   []*FieldUpdateByIDsExpect
	updateByLocationXAndLocationY []*FieldUpdateByLocationXAndLocationYExpect
	updateByName                  []*FieldUpdateByNameExpect
	updateByNames                 []*FieldUpdateByNamesExpect
	updateByObjectNum             []*FieldUpdateByObjectNumExpect
	updateByObjectNums            []*FieldUpdateByObjectNumsExpect
	deleteByDifficultyAndLevel    []*FieldDeleteByDifficultyAndLevelExpect
	deleteByID                    []*FieldDeleteByIDExpect
	deleteByIDs                   []*FieldDeleteByIDsExpect
	deleteByLocationXAndLocationY []*FieldDeleteByLocationXAndLocationYExpect
	deleteByName                  []*FieldDeleteByNameExpect
	deleteByNames                 []*FieldDeleteByNamesExpect
	deleteByObjectNum             []*FieldDeleteByObjectNumExpect
	deleteByObjectNums            []*FieldDeleteByObjectNumsExpect
	count                         []*FieldCountExpect
	delete                        []*FieldDeleteExpect
	update                        []*FieldUpdateExpect
}

func NewFieldExpect() *FieldExpect {
	return &FieldExpect{
		count:                         []*FieldCountExpect{},
		create:                        []*FieldCreateExpect{},
		creates:                       []*FieldCreatesExpect{},
		delete:                        []*FieldDeleteExpect{},
		deleteByDifficultyAndLevel:    []*FieldDeleteByDifficultyAndLevelExpect{},
		deleteByID:                    []*FieldDeleteByIDExpect{},
		deleteByIDs:                   []*FieldDeleteByIDsExpect{},
		deleteByLocationXAndLocationY: []*FieldDeleteByLocationXAndLocationYExpect{},
		deleteByName:                  []*FieldDeleteByNameExpect{},
		deleteByNames:                 []*FieldDeleteByNamesExpect{},
		deleteByObjectNum:             []*FieldDeleteByObjectNumExpect{},
		deleteByObjectNums:            []*FieldDeleteByObjectNumsExpect{},
		findAll:                       []*FieldFindAllExpect{},
		findByDifficulties:            []*FieldFindByDifficultiesExpect{},
		findByDifficulty:              []*FieldFindByDifficultyExpect{},
		findByDifficultyAndLevel:      []*FieldFindByDifficultyAndLevelExpect{},
		findByID:                      []*FieldFindByIDExpect{},
		findByIDs:                     []*FieldFindByIDsExpect{},
		findByLocationX:               []*FieldFindByLocationXExpect{},
		findByLocationXAndLocationY:   []*FieldFindByLocationXAndLocationYExpect{},
		findByLocationXes:             []*FieldFindByLocationXesExpect{},
		findByName:                    []*FieldFindByNameExpect{},
		findByNames:                   []*FieldFindByNamesExpect{},
		findByObjectNum:               []*FieldFindByObjectNumExpect{},
		findByObjectNums:              []*FieldFindByObjectNumsExpect{},
		toModel:                       []*FieldToModelExpect{},
		toModels:                      []*FieldToModelsExpect{},
		update:                        []*FieldUpdateExpect{},
		updateByDifficultyAndLevel:    []*FieldUpdateByDifficultyAndLevelExpect{},
		updateByID:                    []*FieldUpdateByIDExpect{},
		updateByIDs:                   []*FieldUpdateByIDsExpect{},
		updateByLocationXAndLocationY: []*FieldUpdateByLocationXAndLocationYExpect{},
		updateByName:                  []*FieldUpdateByNameExpect{},
		updateByNames:                 []*FieldUpdateByNamesExpect{},
		updateByObjectNum:             []*FieldUpdateByObjectNumExpect{},
		updateByObjectNums:            []*FieldUpdateByObjectNumsExpect{},
	}
}
