// Code generated by eevee. DO NOT EDIT!

package repository

import (
	"context"
	"log"
	"rapidashplugin/entity"
	"rapidashplugin/model"
	"reflect"

	"golang.org/x/xerrors"
)

type UserFieldMock struct {
	expect *UserFieldExpect
}

func (r *UserFieldMock) EXPECT() *UserFieldExpect {
	return r.expect
}

func NewUserFieldMock() *UserFieldMock {
	return &UserFieldMock{expect: NewUserFieldExpect()}
}

type UserFieldToModelExpect struct {
	expect        *UserFieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(value *entity.UserField)
	value         *entity.UserField
	r0            *model.UserField
}

func (r *UserFieldToModelExpect) Return(r0 *model.UserField) *UserFieldToModelExpect {
	r.r0 = r0
	return r
}

func (r *UserFieldToModelExpect) Do(action func(value *entity.UserField)) *UserFieldToModelExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserFieldToModelExpect) OutOfOrder() *UserFieldToModelExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserFieldToModelExpect) AnyTimes() *UserFieldToModelExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserFieldToModelExpect) Times(n int) *UserFieldToModelExpect {
	r.requiredTimes = n
	return r
}

func (r *UserFieldMock) ToModel(value *entity.UserField) (r0 *model.UserField) {
	if len(r.expect.toModel) == 0 {
		log.Printf("cannot find mock method for UserField.ToModel")
		return
	}
	for _, exp := range r.expect.toModel {
		if !reflect.DeepEqual(exp.value, value) {
			continue
		}
		for _, action := range exp.actions {
			action(value)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			log.Printf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	log.Printf("invalid argument UserField value:[%+v]", value)
	return
}

func (r *UserFieldExpect) ToModel(value *entity.UserField) *UserFieldToModelExpect {
	exp := &UserFieldToModelExpect{
		actions: []func(value *entity.UserField){},
		expect:  r,
		value:   value,
	}
	r.toModel = append(r.toModel, exp)
	return exp
}

type UserFieldToModelsExpect struct {
	expect        *UserFieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(values entity.UserFields)
	values        entity.UserFields
	r0            *model.UserFields
}

func (r *UserFieldToModelsExpect) Return(r0 *model.UserFields) *UserFieldToModelsExpect {
	r.r0 = r0
	return r
}

func (r *UserFieldToModelsExpect) Do(action func(values entity.UserFields)) *UserFieldToModelsExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserFieldToModelsExpect) OutOfOrder() *UserFieldToModelsExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserFieldToModelsExpect) AnyTimes() *UserFieldToModelsExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserFieldToModelsExpect) Times(n int) *UserFieldToModelsExpect {
	r.requiredTimes = n
	return r
}

func (r *UserFieldMock) ToModels(values entity.UserFields) (r0 *model.UserFields) {
	if len(r.expect.toModels) == 0 {
		log.Printf("cannot find mock method for UserField.ToModels")
		return
	}
	for _, exp := range r.expect.toModels {
		if !reflect.DeepEqual(exp.values, values) {
			continue
		}
		for _, action := range exp.actions {
			action(values)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			log.Printf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	log.Printf("invalid argument UserField values:[%+v]", values)
	return
}

func (r *UserFieldExpect) ToModels(values entity.UserFields) *UserFieldToModelsExpect {
	exp := &UserFieldToModelsExpect{
		actions: []func(values entity.UserFields){},
		expect:  r,
		values:  values,
	}
	r.toModels = append(r.toModels, exp)
	return exp
}

type UserFieldCreateExpect struct {
	expect        *UserFieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(ctx context.Context, value *entity.UserField)
	ctx           context.Context
	value         *entity.UserField
	r0            *model.UserField
	r1            error
}

func (r *UserFieldCreateExpect) Return(r0 *model.UserField, r1 error) *UserFieldCreateExpect {
	r.r0 = r0
	r.r1 = r1
	return r
}

func (r *UserFieldCreateExpect) Do(action func(ctx context.Context, value *entity.UserField)) *UserFieldCreateExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserFieldCreateExpect) OutOfOrder() *UserFieldCreateExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserFieldCreateExpect) AnyTimes() *UserFieldCreateExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserFieldCreateExpect) Times(n int) *UserFieldCreateExpect {
	r.requiredTimes = n
	return r
}

func (r *UserFieldMock) Create(ctx context.Context, value *entity.UserField) (r0 *model.UserField, r1 error) {
	if len(r.expect.create) == 0 {
		r1 = xerrors.New("cannot find mock method for UserField.Create")
		return
	}
	for _, exp := range r.expect.create {
		if !reflect.DeepEqual(exp.ctx, ctx) {
			continue
		}
		if !reflect.DeepEqual(exp.value, value) {
			continue
		}
		for _, action := range exp.actions {
			action(ctx, value)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			r1 = exp.r1
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r1 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		r1 = exp.r1
		return
	}
	r1 = xerrors.Errorf("invalid argument UserField ctx:[%+v] value:[%+v]", ctx, value)
	return
}

func (r *UserFieldExpect) Create(ctx context.Context, value *entity.UserField) *UserFieldCreateExpect {
	exp := &UserFieldCreateExpect{
		actions: []func(ctx context.Context, value *entity.UserField){},
		ctx:     ctx,
		expect:  r,
		value:   value,
	}
	r.create = append(r.create, exp)
	return exp
}

type UserFieldCreatesExpect struct {
	expect        *UserFieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(ctx context.Context, entities entity.UserFields)
	ctx           context.Context
	entities      entity.UserFields
	r0            *model.UserFields
	r1            error
}

func (r *UserFieldCreatesExpect) Return(r0 *model.UserFields, r1 error) *UserFieldCreatesExpect {
	r.r0 = r0
	r.r1 = r1
	return r
}

func (r *UserFieldCreatesExpect) Do(action func(ctx context.Context, entities entity.UserFields)) *UserFieldCreatesExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserFieldCreatesExpect) OutOfOrder() *UserFieldCreatesExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserFieldCreatesExpect) AnyTimes() *UserFieldCreatesExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserFieldCreatesExpect) Times(n int) *UserFieldCreatesExpect {
	r.requiredTimes = n
	return r
}

func (r *UserFieldMock) Creates(ctx context.Context, entities entity.UserFields) (r0 *model.UserFields, r1 error) {
	if len(r.expect.creates) == 0 {
		r1 = xerrors.New("cannot find mock method for UserField.Creates")
		return
	}
	for _, exp := range r.expect.creates {
		if !reflect.DeepEqual(exp.ctx, ctx) {
			continue
		}
		if !reflect.DeepEqual(exp.entities, entities) {
			continue
		}
		for _, action := range exp.actions {
			action(ctx, entities)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			r1 = exp.r1
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r1 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		r1 = exp.r1
		return
	}
	r1 = xerrors.Errorf("invalid argument UserField ctx:[%+v] entities:[%+v]", ctx, entities)
	return
}

func (r *UserFieldExpect) Creates(ctx context.Context, entities entity.UserFields) *UserFieldCreatesExpect {
	exp := &UserFieldCreatesExpect{
		actions:  []func(ctx context.Context, entities entity.UserFields){},
		ctx:      ctx,
		entities: entities,
		expect:   r,
	}
	r.creates = append(r.creates, exp)
	return exp
}

type UserFieldFindAllExpect struct {
	expect        *UserFieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context)
	a0            context.Context
	r0            *model.UserFields
	r1            error
}

func (r *UserFieldFindAllExpect) Return(r0 *model.UserFields, r1 error) *UserFieldFindAllExpect {
	r.r0 = r0
	r.r1 = r1
	return r
}

func (r *UserFieldFindAllExpect) Do(action func(a0 context.Context)) *UserFieldFindAllExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserFieldFindAllExpect) OutOfOrder() *UserFieldFindAllExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserFieldFindAllExpect) AnyTimes() *UserFieldFindAllExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserFieldFindAllExpect) Times(n int) *UserFieldFindAllExpect {
	r.requiredTimes = n
	return r
}

func (r *UserFieldMock) FindAll(a0 context.Context) (r0 *model.UserFields, r1 error) {
	if len(r.expect.findAll) == 0 {
		r1 = xerrors.New("cannot find mock method for UserField.FindAll")
		return
	}
	for _, exp := range r.expect.findAll {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		for _, action := range exp.actions {
			action(a0)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			r1 = exp.r1
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r1 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		r1 = exp.r1
		return
	}
	r1 = xerrors.Errorf("invalid argument UserField a0:[%+v]", a0)
	return
}

func (r *UserFieldExpect) FindAll(a0 context.Context) *UserFieldFindAllExpect {
	exp := &UserFieldFindAllExpect{
		a0:      a0,
		actions: []func(a0 context.Context){},
		expect:  r,
	}
	r.findAll = append(r.findAll, exp)
	return exp
}

type UserFieldFindByIDExpect struct {
	expect        *UserFieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 uint64)
	a0            context.Context
	a1            uint64
	r0            *model.UserField
	r1            error
}

func (r *UserFieldFindByIDExpect) Return(r0 *model.UserField, r1 error) *UserFieldFindByIDExpect {
	r.r0 = r0
	r.r1 = r1
	return r
}

func (r *UserFieldFindByIDExpect) Do(action func(a0 context.Context, a1 uint64)) *UserFieldFindByIDExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserFieldFindByIDExpect) OutOfOrder() *UserFieldFindByIDExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserFieldFindByIDExpect) AnyTimes() *UserFieldFindByIDExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserFieldFindByIDExpect) Times(n int) *UserFieldFindByIDExpect {
	r.requiredTimes = n
	return r
}

func (r *UserFieldMock) FindByID(a0 context.Context, a1 uint64) (r0 *model.UserField, r1 error) {
	if len(r.expect.findByID) == 0 {
		r1 = xerrors.New("cannot find mock method for UserField.FindByID")
		return
	}
	for _, exp := range r.expect.findByID {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			r1 = exp.r1
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r1 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		r1 = exp.r1
		return
	}
	r1 = xerrors.Errorf("invalid argument UserField a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *UserFieldExpect) FindByID(a0 context.Context, a1 uint64) *UserFieldFindByIDExpect {
	exp := &UserFieldFindByIDExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 uint64){},
		expect:  r,
	}
	r.findByID = append(r.findByID, exp)
	return exp
}

type UserFieldFindByIDsExpect struct {
	expect        *UserFieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 []uint64)
	a0            context.Context
	a1            []uint64
	r0            *model.UserFields
	r1            error
}

func (r *UserFieldFindByIDsExpect) Return(r0 *model.UserFields, r1 error) *UserFieldFindByIDsExpect {
	r.r0 = r0
	r.r1 = r1
	return r
}

func (r *UserFieldFindByIDsExpect) Do(action func(a0 context.Context, a1 []uint64)) *UserFieldFindByIDsExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserFieldFindByIDsExpect) OutOfOrder() *UserFieldFindByIDsExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserFieldFindByIDsExpect) AnyTimes() *UserFieldFindByIDsExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserFieldFindByIDsExpect) Times(n int) *UserFieldFindByIDsExpect {
	r.requiredTimes = n
	return r
}

func (r *UserFieldMock) FindByIDs(a0 context.Context, a1 []uint64) (r0 *model.UserFields, r1 error) {
	if len(r.expect.findByIDs) == 0 {
		r1 = xerrors.New("cannot find mock method for UserField.FindByIDs")
		return
	}
	for _, exp := range r.expect.findByIDs {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if len(exp.a1) != len(a1) {
			continue
		}
		if exp.isOutOfOrder {
			isMatched := func() bool {
				for _, exp := range exp.a1 {
					found := false
					for idx, act := range a1 {
						if exp != act {
							continue
						}
						a1 = append(a1[:idx], a1[idx+1:]...)
						found = true
						break
					}
					if !found {
						return false
					}
				}
				return true
			}()
			if !isMatched {
				continue
			}
		} else {
			if !reflect.DeepEqual(exp.a1, a1) {
				continue
			}
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			r1 = exp.r1
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r1 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		r1 = exp.r1
		return
	}
	r1 = xerrors.Errorf("invalid argument UserField a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *UserFieldExpect) FindByIDs(a0 context.Context, a1 []uint64) *UserFieldFindByIDsExpect {
	exp := &UserFieldFindByIDsExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 []uint64){},
		expect:  r,
	}
	r.findByIDs = append(r.findByIDs, exp)
	return exp
}

type UserFieldFindByUserIDExpect struct {
	expect        *UserFieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 uint64)
	a0            context.Context
	a1            uint64
	r0            *model.UserFields
	r1            error
}

func (r *UserFieldFindByUserIDExpect) Return(r0 *model.UserFields, r1 error) *UserFieldFindByUserIDExpect {
	r.r0 = r0
	r.r1 = r1
	return r
}

func (r *UserFieldFindByUserIDExpect) Do(action func(a0 context.Context, a1 uint64)) *UserFieldFindByUserIDExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserFieldFindByUserIDExpect) OutOfOrder() *UserFieldFindByUserIDExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserFieldFindByUserIDExpect) AnyTimes() *UserFieldFindByUserIDExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserFieldFindByUserIDExpect) Times(n int) *UserFieldFindByUserIDExpect {
	r.requiredTimes = n
	return r
}

func (r *UserFieldMock) FindByUserID(a0 context.Context, a1 uint64) (r0 *model.UserFields, r1 error) {
	if len(r.expect.findByUserID) == 0 {
		r1 = xerrors.New("cannot find mock method for UserField.FindByUserID")
		return
	}
	for _, exp := range r.expect.findByUserID {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			r1 = exp.r1
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r1 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		r1 = exp.r1
		return
	}
	r1 = xerrors.Errorf("invalid argument UserField a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *UserFieldExpect) FindByUserID(a0 context.Context, a1 uint64) *UserFieldFindByUserIDExpect {
	exp := &UserFieldFindByUserIDExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 uint64){},
		expect:  r,
	}
	r.findByUserID = append(r.findByUserID, exp)
	return exp
}

type UserFieldFindByUserIDAndFieldIDExpect struct {
	expect        *UserFieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 uint64, a2 uint64)
	a0            context.Context
	a1            uint64
	a2            uint64
	r0            *model.UserField
	r1            error
}

func (r *UserFieldFindByUserIDAndFieldIDExpect) Return(r0 *model.UserField, r1 error) *UserFieldFindByUserIDAndFieldIDExpect {
	r.r0 = r0
	r.r1 = r1
	return r
}

func (r *UserFieldFindByUserIDAndFieldIDExpect) Do(action func(a0 context.Context, a1 uint64, a2 uint64)) *UserFieldFindByUserIDAndFieldIDExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserFieldFindByUserIDAndFieldIDExpect) OutOfOrder() *UserFieldFindByUserIDAndFieldIDExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserFieldFindByUserIDAndFieldIDExpect) AnyTimes() *UserFieldFindByUserIDAndFieldIDExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserFieldFindByUserIDAndFieldIDExpect) Times(n int) *UserFieldFindByUserIDAndFieldIDExpect {
	r.requiredTimes = n
	return r
}

func (r *UserFieldMock) FindByUserIDAndFieldID(a0 context.Context, a1 uint64, a2 uint64) (r0 *model.UserField, r1 error) {
	if len(r.expect.findByUserIDAndFieldID) == 0 {
		r1 = xerrors.New("cannot find mock method for UserField.FindByUserIDAndFieldID")
		return
	}
	for _, exp := range r.expect.findByUserIDAndFieldID {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		if !reflect.DeepEqual(exp.a2, a2) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1, a2)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			r1 = exp.r1
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r1 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		r1 = exp.r1
		return
	}
	r1 = xerrors.Errorf("invalid argument UserField a0:[%+v] a1:[%+v] a2:[%+v]", a0, a1, a2)
	return
}

func (r *UserFieldExpect) FindByUserIDAndFieldID(a0 context.Context, a1 uint64, a2 uint64) *UserFieldFindByUserIDAndFieldIDExpect {
	exp := &UserFieldFindByUserIDAndFieldIDExpect{
		a0:      a0,
		a1:      a1,
		a2:      a2,
		actions: []func(a0 context.Context, a1 uint64, a2 uint64){},
		expect:  r,
	}
	r.findByUserIDAndFieldID = append(r.findByUserIDAndFieldID, exp)
	return exp
}

type UserFieldFindByUserIDsExpect struct {
	expect        *UserFieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 []uint64)
	a0            context.Context
	a1            []uint64
	r0            *model.UserFields
	r1            error
}

func (r *UserFieldFindByUserIDsExpect) Return(r0 *model.UserFields, r1 error) *UserFieldFindByUserIDsExpect {
	r.r0 = r0
	r.r1 = r1
	return r
}

func (r *UserFieldFindByUserIDsExpect) Do(action func(a0 context.Context, a1 []uint64)) *UserFieldFindByUserIDsExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserFieldFindByUserIDsExpect) OutOfOrder() *UserFieldFindByUserIDsExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserFieldFindByUserIDsExpect) AnyTimes() *UserFieldFindByUserIDsExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserFieldFindByUserIDsExpect) Times(n int) *UserFieldFindByUserIDsExpect {
	r.requiredTimes = n
	return r
}

func (r *UserFieldMock) FindByUserIDs(a0 context.Context, a1 []uint64) (r0 *model.UserFields, r1 error) {
	if len(r.expect.findByUserIDs) == 0 {
		r1 = xerrors.New("cannot find mock method for UserField.FindByUserIDs")
		return
	}
	for _, exp := range r.expect.findByUserIDs {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if len(exp.a1) != len(a1) {
			continue
		}
		if exp.isOutOfOrder {
			isMatched := func() bool {
				for _, exp := range exp.a1 {
					found := false
					for idx, act := range a1 {
						if exp != act {
							continue
						}
						a1 = append(a1[:idx], a1[idx+1:]...)
						found = true
						break
					}
					if !found {
						return false
					}
				}
				return true
			}()
			if !isMatched {
				continue
			}
		} else {
			if !reflect.DeepEqual(exp.a1, a1) {
				continue
			}
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			r1 = exp.r1
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r1 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		r1 = exp.r1
		return
	}
	r1 = xerrors.Errorf("invalid argument UserField a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *UserFieldExpect) FindByUserIDs(a0 context.Context, a1 []uint64) *UserFieldFindByUserIDsExpect {
	exp := &UserFieldFindByUserIDsExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 []uint64){},
		expect:  r,
	}
	r.findByUserIDs = append(r.findByUserIDs, exp)
	return exp
}

type UserFieldUpdateByIDExpect struct {
	expect        *UserFieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 uint64, a2 map[string]interface{})
	a0            context.Context
	a1            uint64
	a2            map[string]interface{}
	r0            error
}

func (r *UserFieldUpdateByIDExpect) Return(r0 error) *UserFieldUpdateByIDExpect {
	r.r0 = r0
	return r
}

func (r *UserFieldUpdateByIDExpect) Do(action func(a0 context.Context, a1 uint64, a2 map[string]interface{})) *UserFieldUpdateByIDExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserFieldUpdateByIDExpect) OutOfOrder() *UserFieldUpdateByIDExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserFieldUpdateByIDExpect) AnyTimes() *UserFieldUpdateByIDExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserFieldUpdateByIDExpect) Times(n int) *UserFieldUpdateByIDExpect {
	r.requiredTimes = n
	return r
}

func (r *UserFieldMock) UpdateByID(a0 context.Context, a1 uint64, a2 map[string]interface{}) (r0 error) {
	if len(r.expect.updateByID) == 0 {
		r0 = xerrors.New("cannot find mock method for UserField.UpdateByID")
		return
	}
	for _, exp := range r.expect.updateByID {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		if !reflect.DeepEqual(exp.a2, a2) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1, a2)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument UserField a0:[%+v] a1:[%+v] a2:[%+v]", a0, a1, a2)
	return
}

func (r *UserFieldExpect) UpdateByID(a0 context.Context, a1 uint64, a2 map[string]interface{}) *UserFieldUpdateByIDExpect {
	exp := &UserFieldUpdateByIDExpect{
		a0:      a0,
		a1:      a1,
		a2:      a2,
		actions: []func(a0 context.Context, a1 uint64, a2 map[string]interface{}){},
		expect:  r,
	}
	r.updateByID = append(r.updateByID, exp)
	return exp
}

type UserFieldUpdateByIDsExpect struct {
	expect        *UserFieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 []uint64, a2 map[string]interface{})
	a0            context.Context
	a1            []uint64
	a2            map[string]interface{}
	r0            error
}

func (r *UserFieldUpdateByIDsExpect) Return(r0 error) *UserFieldUpdateByIDsExpect {
	r.r0 = r0
	return r
}

func (r *UserFieldUpdateByIDsExpect) Do(action func(a0 context.Context, a1 []uint64, a2 map[string]interface{})) *UserFieldUpdateByIDsExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserFieldUpdateByIDsExpect) OutOfOrder() *UserFieldUpdateByIDsExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserFieldUpdateByIDsExpect) AnyTimes() *UserFieldUpdateByIDsExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserFieldUpdateByIDsExpect) Times(n int) *UserFieldUpdateByIDsExpect {
	r.requiredTimes = n
	return r
}

func (r *UserFieldMock) UpdateByIDs(a0 context.Context, a1 []uint64, a2 map[string]interface{}) (r0 error) {
	if len(r.expect.updateByIDs) == 0 {
		r0 = xerrors.New("cannot find mock method for UserField.UpdateByIDs")
		return
	}
	for _, exp := range r.expect.updateByIDs {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if len(exp.a1) != len(a1) {
			continue
		}
		if exp.isOutOfOrder {
			isMatched := func() bool {
				for _, exp := range exp.a1 {
					found := false
					for idx, act := range a1 {
						if exp != act {
							continue
						}
						a1 = append(a1[:idx], a1[idx+1:]...)
						found = true
						break
					}
					if !found {
						return false
					}
				}
				return true
			}()
			if !isMatched {
				continue
			}
		} else {
			if !reflect.DeepEqual(exp.a1, a1) {
				continue
			}
		}
		if !reflect.DeepEqual(exp.a2, a2) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1, a2)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument UserField a0:[%+v] a1:[%+v] a2:[%+v]", a0, a1, a2)
	return
}

func (r *UserFieldExpect) UpdateByIDs(a0 context.Context, a1 []uint64, a2 map[string]interface{}) *UserFieldUpdateByIDsExpect {
	exp := &UserFieldUpdateByIDsExpect{
		a0:      a0,
		a1:      a1,
		a2:      a2,
		actions: []func(a0 context.Context, a1 []uint64, a2 map[string]interface{}){},
		expect:  r,
	}
	r.updateByIDs = append(r.updateByIDs, exp)
	return exp
}

type UserFieldUpdateByUserIDAndFieldIDExpect struct {
	expect        *UserFieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 uint64, a2 uint64, a3 map[string]interface{})
	a0            context.Context
	a1            uint64
	a2            uint64
	a3            map[string]interface{}
	r0            error
}

func (r *UserFieldUpdateByUserIDAndFieldIDExpect) Return(r0 error) *UserFieldUpdateByUserIDAndFieldIDExpect {
	r.r0 = r0
	return r
}

func (r *UserFieldUpdateByUserIDAndFieldIDExpect) Do(action func(a0 context.Context, a1 uint64, a2 uint64, a3 map[string]interface{})) *UserFieldUpdateByUserIDAndFieldIDExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserFieldUpdateByUserIDAndFieldIDExpect) OutOfOrder() *UserFieldUpdateByUserIDAndFieldIDExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserFieldUpdateByUserIDAndFieldIDExpect) AnyTimes() *UserFieldUpdateByUserIDAndFieldIDExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserFieldUpdateByUserIDAndFieldIDExpect) Times(n int) *UserFieldUpdateByUserIDAndFieldIDExpect {
	r.requiredTimes = n
	return r
}

func (r *UserFieldMock) UpdateByUserIDAndFieldID(a0 context.Context, a1 uint64, a2 uint64, a3 map[string]interface{}) (r0 error) {
	if len(r.expect.updateByUserIDAndFieldID) == 0 {
		r0 = xerrors.New("cannot find mock method for UserField.UpdateByUserIDAndFieldID")
		return
	}
	for _, exp := range r.expect.updateByUserIDAndFieldID {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		if !reflect.DeepEqual(exp.a2, a2) {
			continue
		}
		if !reflect.DeepEqual(exp.a3, a3) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1, a2, a3)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument UserField a0:[%+v] a1:[%+v] a2:[%+v] a3:[%+v]", a0, a1, a2, a3)
	return
}

func (r *UserFieldExpect) UpdateByUserIDAndFieldID(a0 context.Context, a1 uint64, a2 uint64, a3 map[string]interface{}) *UserFieldUpdateByUserIDAndFieldIDExpect {
	exp := &UserFieldUpdateByUserIDAndFieldIDExpect{
		a0:      a0,
		a1:      a1,
		a2:      a2,
		a3:      a3,
		actions: []func(a0 context.Context, a1 uint64, a2 uint64, a3 map[string]interface{}){},
		expect:  r,
	}
	r.updateByUserIDAndFieldID = append(r.updateByUserIDAndFieldID, exp)
	return exp
}

type UserFieldDeleteByIDExpect struct {
	expect        *UserFieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 uint64)
	a0            context.Context
	a1            uint64
	r0            error
}

func (r *UserFieldDeleteByIDExpect) Return(r0 error) *UserFieldDeleteByIDExpect {
	r.r0 = r0
	return r
}

func (r *UserFieldDeleteByIDExpect) Do(action func(a0 context.Context, a1 uint64)) *UserFieldDeleteByIDExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserFieldDeleteByIDExpect) OutOfOrder() *UserFieldDeleteByIDExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserFieldDeleteByIDExpect) AnyTimes() *UserFieldDeleteByIDExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserFieldDeleteByIDExpect) Times(n int) *UserFieldDeleteByIDExpect {
	r.requiredTimes = n
	return r
}

func (r *UserFieldMock) DeleteByID(a0 context.Context, a1 uint64) (r0 error) {
	if len(r.expect.deleteByID) == 0 {
		r0 = xerrors.New("cannot find mock method for UserField.DeleteByID")
		return
	}
	for _, exp := range r.expect.deleteByID {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument UserField a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *UserFieldExpect) DeleteByID(a0 context.Context, a1 uint64) *UserFieldDeleteByIDExpect {
	exp := &UserFieldDeleteByIDExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 uint64){},
		expect:  r,
	}
	r.deleteByID = append(r.deleteByID, exp)
	return exp
}

type UserFieldDeleteByIDsExpect struct {
	expect        *UserFieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 []uint64)
	a0            context.Context
	a1            []uint64
	r0            error
}

func (r *UserFieldDeleteByIDsExpect) Return(r0 error) *UserFieldDeleteByIDsExpect {
	r.r0 = r0
	return r
}

func (r *UserFieldDeleteByIDsExpect) Do(action func(a0 context.Context, a1 []uint64)) *UserFieldDeleteByIDsExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserFieldDeleteByIDsExpect) OutOfOrder() *UserFieldDeleteByIDsExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserFieldDeleteByIDsExpect) AnyTimes() *UserFieldDeleteByIDsExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserFieldDeleteByIDsExpect) Times(n int) *UserFieldDeleteByIDsExpect {
	r.requiredTimes = n
	return r
}

func (r *UserFieldMock) DeleteByIDs(a0 context.Context, a1 []uint64) (r0 error) {
	if len(r.expect.deleteByIDs) == 0 {
		r0 = xerrors.New("cannot find mock method for UserField.DeleteByIDs")
		return
	}
	for _, exp := range r.expect.deleteByIDs {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if len(exp.a1) != len(a1) {
			continue
		}
		if exp.isOutOfOrder {
			isMatched := func() bool {
				for _, exp := range exp.a1 {
					found := false
					for idx, act := range a1 {
						if exp != act {
							continue
						}
						a1 = append(a1[:idx], a1[idx+1:]...)
						found = true
						break
					}
					if !found {
						return false
					}
				}
				return true
			}()
			if !isMatched {
				continue
			}
		} else {
			if !reflect.DeepEqual(exp.a1, a1) {
				continue
			}
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument UserField a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *UserFieldExpect) DeleteByIDs(a0 context.Context, a1 []uint64) *UserFieldDeleteByIDsExpect {
	exp := &UserFieldDeleteByIDsExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 []uint64){},
		expect:  r,
	}
	r.deleteByIDs = append(r.deleteByIDs, exp)
	return exp
}

type UserFieldDeleteByUserIDAndFieldIDExpect struct {
	expect        *UserFieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 uint64, a2 uint64)
	a0            context.Context
	a1            uint64
	a2            uint64
	r0            error
}

func (r *UserFieldDeleteByUserIDAndFieldIDExpect) Return(r0 error) *UserFieldDeleteByUserIDAndFieldIDExpect {
	r.r0 = r0
	return r
}

func (r *UserFieldDeleteByUserIDAndFieldIDExpect) Do(action func(a0 context.Context, a1 uint64, a2 uint64)) *UserFieldDeleteByUserIDAndFieldIDExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserFieldDeleteByUserIDAndFieldIDExpect) OutOfOrder() *UserFieldDeleteByUserIDAndFieldIDExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserFieldDeleteByUserIDAndFieldIDExpect) AnyTimes() *UserFieldDeleteByUserIDAndFieldIDExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserFieldDeleteByUserIDAndFieldIDExpect) Times(n int) *UserFieldDeleteByUserIDAndFieldIDExpect {
	r.requiredTimes = n
	return r
}

func (r *UserFieldMock) DeleteByUserIDAndFieldID(a0 context.Context, a1 uint64, a2 uint64) (r0 error) {
	if len(r.expect.deleteByUserIDAndFieldID) == 0 {
		r0 = xerrors.New("cannot find mock method for UserField.DeleteByUserIDAndFieldID")
		return
	}
	for _, exp := range r.expect.deleteByUserIDAndFieldID {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		if !reflect.DeepEqual(exp.a2, a2) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1, a2)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument UserField a0:[%+v] a1:[%+v] a2:[%+v]", a0, a1, a2)
	return
}

func (r *UserFieldExpect) DeleteByUserIDAndFieldID(a0 context.Context, a1 uint64, a2 uint64) *UserFieldDeleteByUserIDAndFieldIDExpect {
	exp := &UserFieldDeleteByUserIDAndFieldIDExpect{
		a0:      a0,
		a1:      a1,
		a2:      a2,
		actions: []func(a0 context.Context, a1 uint64, a2 uint64){},
		expect:  r,
	}
	r.deleteByUserIDAndFieldID = append(r.deleteByUserIDAndFieldID, exp)
	return exp
}

type UserFieldCountExpect struct {
	expect        *UserFieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context)
	a0            context.Context
	r0            int64
	r1            error
}

func (r *UserFieldCountExpect) Return(r0 int64, r1 error) *UserFieldCountExpect {
	r.r0 = r0
	r.r1 = r1
	return r
}

func (r *UserFieldCountExpect) Do(action func(a0 context.Context)) *UserFieldCountExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserFieldCountExpect) OutOfOrder() *UserFieldCountExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserFieldCountExpect) AnyTimes() *UserFieldCountExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserFieldCountExpect) Times(n int) *UserFieldCountExpect {
	r.requiredTimes = n
	return r
}

func (r *UserFieldMock) Count(a0 context.Context) (r0 int64, r1 error) {
	if len(r.expect.count) == 0 {
		r1 = xerrors.New("cannot find mock method for UserField.Count")
		return
	}
	for _, exp := range r.expect.count {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		for _, action := range exp.actions {
			action(a0)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			r1 = exp.r1
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r1 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		r1 = exp.r1
		return
	}
	r1 = xerrors.Errorf("invalid argument UserField a0:[%+v]", a0)
	return
}

func (r *UserFieldExpect) Count(a0 context.Context) *UserFieldCountExpect {
	exp := &UserFieldCountExpect{
		a0:      a0,
		actions: []func(a0 context.Context){},
		expect:  r,
	}
	r.count = append(r.count, exp)
	return exp
}

type UserFieldDeleteExpect struct {
	expect        *UserFieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 *entity.UserField)
	a0            context.Context
	a1            *entity.UserField
	r0            error
}

func (r *UserFieldDeleteExpect) Return(r0 error) *UserFieldDeleteExpect {
	r.r0 = r0
	return r
}

func (r *UserFieldDeleteExpect) Do(action func(a0 context.Context, a1 *entity.UserField)) *UserFieldDeleteExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserFieldDeleteExpect) OutOfOrder() *UserFieldDeleteExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserFieldDeleteExpect) AnyTimes() *UserFieldDeleteExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserFieldDeleteExpect) Times(n int) *UserFieldDeleteExpect {
	r.requiredTimes = n
	return r
}

func (r *UserFieldMock) Delete(a0 context.Context, a1 *entity.UserField) (r0 error) {
	if len(r.expect.delete) == 0 {
		r0 = xerrors.New("cannot find mock method for UserField.Delete")
		return
	}
	for _, exp := range r.expect.delete {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument UserField a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *UserFieldExpect) Delete(a0 context.Context, a1 *entity.UserField) *UserFieldDeleteExpect {
	exp := &UserFieldDeleteExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 *entity.UserField){},
		expect:  r,
	}
	r.delete = append(r.delete, exp)
	return exp
}

type UserFieldUpdateExpect struct {
	expect        *UserFieldExpect
	isOutOfOrder  bool
	isAnyTimes    bool
	requiredTimes int
	calledTimes   int
	actions       []func(a0 context.Context, a1 *entity.UserField)
	a0            context.Context
	a1            *entity.UserField
	r0            error
}

func (r *UserFieldUpdateExpect) Return(r0 error) *UserFieldUpdateExpect {
	r.r0 = r0
	return r
}

func (r *UserFieldUpdateExpect) Do(action func(a0 context.Context, a1 *entity.UserField)) *UserFieldUpdateExpect {
	r.actions = append(r.actions, action)
	return r
}

func (r *UserFieldUpdateExpect) OutOfOrder() *UserFieldUpdateExpect {
	r.isOutOfOrder = true
	return r
}

func (r *UserFieldUpdateExpect) AnyTimes() *UserFieldUpdateExpect {
	r.isAnyTimes = true
	return r
}

func (r *UserFieldUpdateExpect) Times(n int) *UserFieldUpdateExpect {
	r.requiredTimes = n
	return r
}

func (r *UserFieldMock) Update(a0 context.Context, a1 *entity.UserField) (r0 error) {
	if len(r.expect.update) == 0 {
		r0 = xerrors.New("cannot find mock method for UserField.Update")
		return
	}
	for _, exp := range r.expect.update {
		if !reflect.DeepEqual(exp.a0, a0) {
			continue
		}
		if !reflect.DeepEqual(exp.a1, a1) {
			continue
		}
		for _, action := range exp.actions {
			action(a0, a1)
		}
		if exp.isAnyTimes {
			r0 = exp.r0
			return
		}
		if exp.requiredTimes > 1 && exp.calledTimes > exp.requiredTimes {
			r0 = xerrors.Errorf("invalid call times. requiredTimes: [%d] calledTimes: [%d]", exp.requiredTimes, exp.calledTimes)
			return
		}
		exp.calledTimes++
		r0 = exp.r0
		return
	}
	r0 = xerrors.Errorf("invalid argument UserField a0:[%+v] a1:[%+v]", a0, a1)
	return
}

func (r *UserFieldExpect) Update(a0 context.Context, a1 *entity.UserField) *UserFieldUpdateExpect {
	exp := &UserFieldUpdateExpect{
		a0:      a0,
		a1:      a1,
		actions: []func(a0 context.Context, a1 *entity.UserField){},
		expect:  r,
	}
	r.update = append(r.update, exp)
	return exp
}

type UserFieldExpect struct {
	toModel                  []*UserFieldToModelExpect
	toModels                 []*UserFieldToModelsExpect
	create                   []*UserFieldCreateExpect
	creates                  []*UserFieldCreatesExpect
	findAll                  []*UserFieldFindAllExpect
	findByID                 []*UserFieldFindByIDExpect
	findByIDs                []*UserFieldFindByIDsExpect
	findByUserID             []*UserFieldFindByUserIDExpect
	findByUserIDAndFieldID   []*UserFieldFindByUserIDAndFieldIDExpect
	findByUserIDs            []*UserFieldFindByUserIDsExpect
	updateByID               []*UserFieldUpdateByIDExpect
	updateByIDs              []*UserFieldUpdateByIDsExpect
	updateByUserIDAndFieldID []*UserFieldUpdateByUserIDAndFieldIDExpect
	deleteByID               []*UserFieldDeleteByIDExpect
	deleteByIDs              []*UserFieldDeleteByIDsExpect
	deleteByUserIDAndFieldID []*UserFieldDeleteByUserIDAndFieldIDExpect
	count                    []*UserFieldCountExpect
	delete                   []*UserFieldDeleteExpect
	update                   []*UserFieldUpdateExpect
}

func NewUserFieldExpect() *UserFieldExpect {
	return &UserFieldExpect{
		count:                    []*UserFieldCountExpect{},
		create:                   []*UserFieldCreateExpect{},
		creates:                  []*UserFieldCreatesExpect{},
		delete:                   []*UserFieldDeleteExpect{},
		deleteByID:               []*UserFieldDeleteByIDExpect{},
		deleteByIDs:              []*UserFieldDeleteByIDsExpect{},
		deleteByUserIDAndFieldID: []*UserFieldDeleteByUserIDAndFieldIDExpect{},
		findAll:                  []*UserFieldFindAllExpect{},
		findByID:                 []*UserFieldFindByIDExpect{},
		findByIDs:                []*UserFieldFindByIDsExpect{},
		findByUserID:             []*UserFieldFindByUserIDExpect{},
		findByUserIDAndFieldID:   []*UserFieldFindByUserIDAndFieldIDExpect{},
		findByUserIDs:            []*UserFieldFindByUserIDsExpect{},
		toModel:                  []*UserFieldToModelExpect{},
		toModels:                 []*UserFieldToModelsExpect{},
		update:                   []*UserFieldUpdateExpect{},
		updateByID:               []*UserFieldUpdateByIDExpect{},
		updateByIDs:              []*UserFieldUpdateByIDsExpect{},
		updateByUserIDAndFieldID: []*UserFieldUpdateByUserIDAndFieldIDExpect{},
	}
}
