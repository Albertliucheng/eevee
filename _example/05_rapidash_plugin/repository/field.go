// Code generated by eevee. DO NOT EDIT!

package repository

import (
	"context"
	"rapidashplugin/dao"
	"rapidashplugin/entity"
	"rapidashplugin/model"

	rapidash "go.knocknote.io/rapidash"
	"golang.org/x/xerrors"
)

type Field interface {
	ToModel(*entity.Field) *model.Field
	ToModels(entity.Fields) *model.Fields
	Create(context.Context, *entity.Field) (*model.Field, error)
	Creates(context.Context, entity.Fields) (*model.Fields, error)
	FindAll(context.Context) (*model.Fields, error)
	FindByDifficulties(context.Context, []int) (*model.Fields, error)
	FindByDifficulty(context.Context, int) (*model.Fields, error)
	FindByDifficultyAndLevel(context.Context, int, int) (*model.Fields, error)
	FindByID(context.Context, uint64) (*model.Field, error)
	FindByIDs(context.Context, []uint64) (*model.Fields, error)
	FindByLocationX(context.Context, int) (*model.Fields, error)
	FindByLocationXAndLocationY(context.Context, int, int) (*model.Field, error)
	FindByLocationXes(context.Context, []int) (*model.Fields, error)
	FindByName(context.Context, string) (*model.Field, error)
	FindByNames(context.Context, []string) (*model.Fields, error)
	FindByObjectNum(context.Context, int) (*model.Fields, error)
	FindByObjectNums(context.Context, []int) (*model.Fields, error)
	UpdateByDifficultyAndLevel(context.Context, int, int, map[string]interface{}) error
	UpdateByID(context.Context, uint64, map[string]interface{}) error
	UpdateByIDs(context.Context, []uint64, map[string]interface{}) error
	UpdateByLocationXAndLocationY(context.Context, int, int, map[string]interface{}) error
	UpdateByName(context.Context, string, map[string]interface{}) error
	UpdateByNames(context.Context, []string, map[string]interface{}) error
	UpdateByObjectNum(context.Context, int, map[string]interface{}) error
	UpdateByObjectNums(context.Context, []int, map[string]interface{}) error
	DeleteByDifficultyAndLevel(context.Context, int, int) error
	DeleteByID(context.Context, uint64) error
	DeleteByIDs(context.Context, []uint64) error
	DeleteByLocationXAndLocationY(context.Context, int, int) error
	DeleteByName(context.Context, string) error
	DeleteByNames(context.Context, []string) error
	DeleteByObjectNum(context.Context, int) error
	DeleteByObjectNums(context.Context, []int) error
	Count(context.Context) (int64, error)
	Delete(context.Context, *entity.Field) error
	Update(context.Context, *entity.Field) error
}

type FieldImpl struct {
	fieldDAO dao.Field
	repo     Repository
}

func NewField(ctx context.Context, tx *rapidash.Tx) *FieldImpl {
	return &FieldImpl{fieldDAO: dao.NewField(ctx, tx)}
}

func (r *FieldImpl) ToModel(value *entity.Field) *model.Field {
	return r.createCollection(entity.Fields{value}).First()
}

func (r *FieldImpl) ToModels(values entity.Fields) *model.Fields {
	return r.createCollection(values)
}

func (r *FieldImpl) Create(ctx context.Context, value *entity.Field) (*model.Field, error) {
	if err := r.fieldDAO.Create(ctx, value); err != nil {
		return nil, xerrors.Errorf("cannot Create: %w", err)
	}
	v := r.ToModel(value)
	v.SetSavedValue(value)
	v.SetAlreadyCreated(true)
	return v, nil
}

func (r *FieldImpl) Creates(ctx context.Context, entities entity.Fields) (*model.Fields, error) {
	for _, v := range entities {
		if _, err := r.Create(ctx, v); err != nil {
			return nil, xerrors.Errorf("cannot Create: %w", err)
		}
	}
	values := r.ToModels(entities)
	values.Each(func(v *model.Field) {
		v.SetSavedValue(v.Field)
		v.SetAlreadyCreated(true)
	})
	return values, nil
}

func (r *FieldImpl) FindAll(a0 context.Context) (*model.Fields, error) {
	values, err := r.fieldDAO.FindAll(a0)
	if err != nil {
		return nil, xerrors.Errorf("failed to FindAll: %w", err)
	}
	collection := r.createCollection(values)
	collection.Each(func(v *model.Field) {
		v.SetSavedValue(v.Field)
		v.SetAlreadyCreated(true)
	})
	return collection, nil
}

func (r *FieldImpl) FindByDifficulties(a0 context.Context, a1 []int) (*model.Fields, error) {
	values, err := r.fieldDAO.FindByDifficulties(a0, a1)
	if err != nil {
		return nil, xerrors.Errorf("failed to FindByDifficulties: %w", err)
	}
	collection := r.createCollection(values)
	collection.Each(func(v *model.Field) {
		v.SetSavedValue(v.Field)
		v.SetAlreadyCreated(true)
	})
	return collection, nil
}

func (r *FieldImpl) FindByDifficulty(a0 context.Context, a1 int) (*model.Fields, error) {
	values, err := r.fieldDAO.FindByDifficulty(a0, a1)
	if err != nil {
		return nil, xerrors.Errorf("failed to FindByDifficulty: %w", err)
	}
	collection := r.createCollection(values)
	collection.Each(func(v *model.Field) {
		v.SetSavedValue(v.Field)
		v.SetAlreadyCreated(true)
	})
	return collection, nil
}

func (r *FieldImpl) FindByDifficultyAndLevel(a0 context.Context, a1 int, a2 int) (*model.Fields, error) {
	values, err := r.fieldDAO.FindByDifficultyAndLevel(a0, a1, a2)
	if err != nil {
		return nil, xerrors.Errorf("failed to FindByDifficultyAndLevel: %w", err)
	}
	collection := r.createCollection(values)
	collection.Each(func(v *model.Field) {
		v.SetSavedValue(v.Field)
		v.SetAlreadyCreated(true)
	})
	return collection, nil
}

func (r *FieldImpl) FindByID(a0 context.Context, a1 uint64) (*model.Field, error) {
	value, err := r.fieldDAO.FindByID(a0, a1)
	if err != nil {
		return nil, xerrors.Errorf("failed to FindByID: %w", err)
	}
	if value == nil {
		return nil, nil
	}
	v := r.createCollection(entity.Fields{value}).First()
	v.SetSavedValue(v.Field)
	v.SetAlreadyCreated(true)
	return v, nil
}

func (r *FieldImpl) FindByIDs(a0 context.Context, a1 []uint64) (*model.Fields, error) {
	values, err := r.fieldDAO.FindByIDs(a0, a1)
	if err != nil {
		return nil, xerrors.Errorf("failed to FindByIDs: %w", err)
	}
	collection := r.createCollection(values)
	collection.Each(func(v *model.Field) {
		v.SetSavedValue(v.Field)
		v.SetAlreadyCreated(true)
	})
	return collection, nil
}

func (r *FieldImpl) FindByLocationX(a0 context.Context, a1 int) (*model.Fields, error) {
	values, err := r.fieldDAO.FindByLocationX(a0, a1)
	if err != nil {
		return nil, xerrors.Errorf("failed to FindByLocationX: %w", err)
	}
	collection := r.createCollection(values)
	collection.Each(func(v *model.Field) {
		v.SetSavedValue(v.Field)
		v.SetAlreadyCreated(true)
	})
	return collection, nil
}

func (r *FieldImpl) FindByLocationXAndLocationY(a0 context.Context, a1 int, a2 int) (*model.Field, error) {
	value, err := r.fieldDAO.FindByLocationXAndLocationY(a0, a1, a2)
	if err != nil {
		return nil, xerrors.Errorf("failed to FindByLocationXAndLocationY: %w", err)
	}
	if value == nil {
		return nil, nil
	}
	v := r.createCollection(entity.Fields{value}).First()
	v.SetSavedValue(v.Field)
	v.SetAlreadyCreated(true)
	return v, nil
}

func (r *FieldImpl) FindByLocationXes(a0 context.Context, a1 []int) (*model.Fields, error) {
	values, err := r.fieldDAO.FindByLocationXes(a0, a1)
	if err != nil {
		return nil, xerrors.Errorf("failed to FindByLocationXes: %w", err)
	}
	collection := r.createCollection(values)
	collection.Each(func(v *model.Field) {
		v.SetSavedValue(v.Field)
		v.SetAlreadyCreated(true)
	})
	return collection, nil
}

func (r *FieldImpl) FindByName(a0 context.Context, a1 string) (*model.Field, error) {
	value, err := r.fieldDAO.FindByName(a0, a1)
	if err != nil {
		return nil, xerrors.Errorf("failed to FindByName: %w", err)
	}
	if value == nil {
		return nil, nil
	}
	v := r.createCollection(entity.Fields{value}).First()
	v.SetSavedValue(v.Field)
	v.SetAlreadyCreated(true)
	return v, nil
}

func (r *FieldImpl) FindByNames(a0 context.Context, a1 []string) (*model.Fields, error) {
	values, err := r.fieldDAO.FindByNames(a0, a1)
	if err != nil {
		return nil, xerrors.Errorf("failed to FindByNames: %w", err)
	}
	collection := r.createCollection(values)
	collection.Each(func(v *model.Field) {
		v.SetSavedValue(v.Field)
		v.SetAlreadyCreated(true)
	})
	return collection, nil
}

func (r *FieldImpl) FindByObjectNum(a0 context.Context, a1 int) (*model.Fields, error) {
	values, err := r.fieldDAO.FindByObjectNum(a0, a1)
	if err != nil {
		return nil, xerrors.Errorf("failed to FindByObjectNum: %w", err)
	}
	collection := r.createCollection(values)
	collection.Each(func(v *model.Field) {
		v.SetSavedValue(v.Field)
		v.SetAlreadyCreated(true)
	})
	return collection, nil
}

func (r *FieldImpl) FindByObjectNums(a0 context.Context, a1 []int) (*model.Fields, error) {
	values, err := r.fieldDAO.FindByObjectNums(a0, a1)
	if err != nil {
		return nil, xerrors.Errorf("failed to FindByObjectNums: %w", err)
	}
	collection := r.createCollection(values)
	collection.Each(func(v *model.Field) {
		v.SetSavedValue(v.Field)
		v.SetAlreadyCreated(true)
	})
	return collection, nil
}

func (r *FieldImpl) UpdateByDifficultyAndLevel(a0 context.Context, a1 int, a2 int, a3 map[string]interface{}) error {
	if err := r.fieldDAO.UpdateByDifficultyAndLevel(a0, a1, a2, a3); err != nil {
		return xerrors.Errorf("failed to update: %w", err)
	}
	return nil
}

func (r *FieldImpl) UpdateByID(a0 context.Context, a1 uint64, a2 map[string]interface{}) error {
	if err := r.fieldDAO.UpdateByID(a0, a1, a2); err != nil {
		return xerrors.Errorf("failed to update: %w", err)
	}
	return nil
}

func (r *FieldImpl) UpdateByIDs(a0 context.Context, a1 []uint64, a2 map[string]interface{}) error {
	if err := r.fieldDAO.UpdateByIDs(a0, a1, a2); err != nil {
		return xerrors.Errorf("failed to update: %w", err)
	}
	return nil
}

func (r *FieldImpl) UpdateByLocationXAndLocationY(a0 context.Context, a1 int, a2 int, a3 map[string]interface{}) error {
	if err := r.fieldDAO.UpdateByLocationXAndLocationY(a0, a1, a2, a3); err != nil {
		return xerrors.Errorf("failed to update: %w", err)
	}
	return nil
}

func (r *FieldImpl) UpdateByName(a0 context.Context, a1 string, a2 map[string]interface{}) error {
	if err := r.fieldDAO.UpdateByName(a0, a1, a2); err != nil {
		return xerrors.Errorf("failed to update: %w", err)
	}
	return nil
}

func (r *FieldImpl) UpdateByNames(a0 context.Context, a1 []string, a2 map[string]interface{}) error {
	if err := r.fieldDAO.UpdateByNames(a0, a1, a2); err != nil {
		return xerrors.Errorf("failed to update: %w", err)
	}
	return nil
}

func (r *FieldImpl) UpdateByObjectNum(a0 context.Context, a1 int, a2 map[string]interface{}) error {
	if err := r.fieldDAO.UpdateByObjectNum(a0, a1, a2); err != nil {
		return xerrors.Errorf("failed to update: %w", err)
	}
	return nil
}

func (r *FieldImpl) UpdateByObjectNums(a0 context.Context, a1 []int, a2 map[string]interface{}) error {
	if err := r.fieldDAO.UpdateByObjectNums(a0, a1, a2); err != nil {
		return xerrors.Errorf("failed to update: %w", err)
	}
	return nil
}

func (r *FieldImpl) DeleteByDifficultyAndLevel(a0 context.Context, a1 int, a2 int) error {
	if err := r.fieldDAO.DeleteByDifficultyAndLevel(a0, a1, a2); err != nil {
		return xerrors.Errorf("failed to delete: %w", err)
	}
	return nil
}

func (r *FieldImpl) DeleteByID(a0 context.Context, a1 uint64) error {
	if err := r.fieldDAO.DeleteByID(a0, a1); err != nil {
		return xerrors.Errorf("failed to delete: %w", err)
	}
	return nil
}

func (r *FieldImpl) DeleteByIDs(a0 context.Context, a1 []uint64) error {
	if err := r.fieldDAO.DeleteByIDs(a0, a1); err != nil {
		return xerrors.Errorf("failed to delete: %w", err)
	}
	return nil
}

func (r *FieldImpl) DeleteByLocationXAndLocationY(a0 context.Context, a1 int, a2 int) error {
	if err := r.fieldDAO.DeleteByLocationXAndLocationY(a0, a1, a2); err != nil {
		return xerrors.Errorf("failed to delete: %w", err)
	}
	return nil
}

func (r *FieldImpl) DeleteByName(a0 context.Context, a1 string) error {
	if err := r.fieldDAO.DeleteByName(a0, a1); err != nil {
		return xerrors.Errorf("failed to delete: %w", err)
	}
	return nil
}

func (r *FieldImpl) DeleteByNames(a0 context.Context, a1 []string) error {
	if err := r.fieldDAO.DeleteByNames(a0, a1); err != nil {
		return xerrors.Errorf("failed to delete: %w", err)
	}
	return nil
}

func (r *FieldImpl) DeleteByObjectNum(a0 context.Context, a1 int) error {
	if err := r.fieldDAO.DeleteByObjectNum(a0, a1); err != nil {
		return xerrors.Errorf("failed to delete: %w", err)
	}
	return nil
}

func (r *FieldImpl) DeleteByObjectNums(a0 context.Context, a1 []int) error {
	if err := r.fieldDAO.DeleteByObjectNums(a0, a1); err != nil {
		return xerrors.Errorf("failed to delete: %w", err)
	}
	return nil
}

func (r *FieldImpl) Count(a0 context.Context) (r0 int64, r1 error) {
	r0, r1 = r.fieldDAO.Count(a0)
	if r1 != nil {
		r1 = xerrors.Errorf("failed to Count: %w", r1)
	}
	return
}

func (r *FieldImpl) Delete(a0 context.Context, a1 *entity.Field) (r0 error) {
	r0 = r.fieldDAO.Delete(a0, a1)
	if r0 != nil {
		r0 = xerrors.Errorf("failed to Delete: %w", r0)
	}
	return
}

func (r *FieldImpl) Update(a0 context.Context, a1 *entity.Field) (r0 error) {
	r0 = r.fieldDAO.Update(a0, a1)
	if r0 != nil {
		r0 = xerrors.Errorf("failed to Update: %w", r0)
	}
	return
}

func (r *FieldImpl) createCollection(entities entity.Fields) *model.Fields {
	values := model.NewFields(entities)
	for i := 0; i < len(entities); i += 1 {
		values.Add(r.create(entities[i], values))
	}
	return values
}

func (r *FieldImpl) create(entity *entity.Field, values *model.Fields) *model.Field {
	value := model.NewField(entity, r.fieldDAO)
	value.SetConverter(r.repo.(model.ModelConverter))
	return value
}
